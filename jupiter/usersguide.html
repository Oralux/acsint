<HTML>
<FONT face=Arial,Helvetica,sans-serif size=4>
<HEAD>
<META name=description content="jupiter documentation, a linear adapter for the blind.">
<meta name=keywords content="
text based, command line, interactive, linear,
adapter, speech, blind, customizable">
<TITLE> Jupiter Documentation </TITLE>
<LINK REL="SHORTCUT ICON" href="pc.ico">
</HEAD>
<BODY bgcolor=white text=black link=red vlink=red alink=navy>

<H2 align=center> Jupiter Documentation, a User's Guide </H2>

<H3 align=center> <A NAME=top> Contents </A> </H3>

<UL>
<LI><A HREF=#auth> Author </A>
<LI><A HREF=#copy> Copyright Notice </A>
<LI><A HREF=#over> Overview </A>
<LI><A HREF=#lang> Other Languages </A>
<LI><A HREF=#syn> Synthesizers </A>
<LI><A HREF=#mod> Modules </A>
<LI><A HREF=#modes> Modes </A>
<LI><A HREF=#cfg> Config Files </A>
<LI><A HREF=#rc> The Reading Cursor and Atomic Commands </A>
</UL>

<H3 align=center> <A NAME=auth> Author </A> </H3>

Karl Dahlke
<A HREF=mailto:eklhad@gmail.com>eklhad@gmail.com</A>

<H3 align=center> <A NAME=copy> Copyright Notice </A> </H3>

This program is copyright &copy; Karl Dahlke, 2000-2014.&nbsp;
It is made available by the author under the terms of the GNU General Public License (GPL),
as articulated by the Free Software Foundation.&nbsp;
It may be used for any purpose, and redistributed, provided this copyright notice is included.

<H3 align=center> <A NAME=over> Overview </A> </H3>

Jupiter is unique among all adapters in that it does not (by default) transform the words or icons on the screen into speech or braille.&nbsp;
It is not typically used as a screen reader.&nbsp;
It is capable of reading screen memory
and interacting with certain curses programs,
but it typically runs in linear mode,
capturing all tty output like a paper teletype and making it available to the blind user through speech.&nbsp;
The buffer is 64K, and could represent several hours of work,
depending on the nature and quantity of output during that time.&nbsp;
Or it could represent just a few seconds of output, if a program prints "hello world" in an infinite loop.

<P>
I call this a linear adapter, rather than a screen reader,
because it maintains a linear buffer of tty output,
and allows the blind user to move about within this buffer and read the accumulated text.&nbsp;
This is part of a larger philosophy,
wherein editers, browsers, mail clients, spreadsheets, and other critical applications
are rewritten from the ground up if necessary
to support various disabilities.&nbsp;
Once this is done,
Other applications can leverage these tools,
and be immediately accessible to a wide range of computer users.&nbsp;
You can read more about this philosophy
<A HREF=http://www.eklhad.net/edbrowse/philosophy.html>here</A>.

<P>
Although Jupiter is interoperable with some curses-based screen programs,
it is incompatible with a graphical desktop such as gnome or kde.&nbsp;
More generally, Jupiter is incompatible with X, which bypasses the traditional tty driver entirely.&nbsp;
It doesn't see the output, and certainly can't read it to you.&nbsp;
Instead, Jupiter was written for people who spend most of their time at run level 3,
logged into a text based console.&nbsp;
Furthermore, it is most effective when combined with command line programs such as bash,
fdisk, mpg123, ed, and of course edbrowse.

<P>
The tty buffers are maintained per console -
thus Jupiter is most effective when combined with the 12 virtual consoles that come standard in Linux,
accessible by alt F1 through alt F12.&nbsp;
Switch to console 7 and you will be reading the tty buffer associated with that console,
i.e. the output of the programs that have been run from that console.&nbsp;
If you use screen(1) to maintain parallel sessions,
the output of all your sessions will intermix in the tty buffer,
and the result will be very confusing.&nbsp;
I therefore recommend 12 or 24 virtual text-based consoles
to manage your parallel sessions.

<H3 align=center> <A NAME=lang> Other Languages </A> </H3>

The buffer stores tty output in unicode, which is compatible with every language on Earth.&nbsp;
Thus, in theory, Jupiter could be modified to support any language.&nbsp;
At present it supports English, German, and Brazilian Portuguese.&nbsp;
If you are interested in other languages, or if you can help in this effort, please let me know.&nbsp;
You don't have to be a programmer;
you just have to be fluent in your language and conversational in English.&nbsp;
I will do the rest.

<H3 align=center> <A NAME=syn> Synthesizers </A> </H3>

This adapter, like Speakup or Window Eyes or any other adapter, requires a speech synthesizer.&nbsp;
There are two flavors.&nbsp;
An external synthesizer plugs into the serial port on your computer
and runs as a peripheral,
apart from your sound card and speakers.&nbsp;
In contrast, a software synthesizer is a program that runs on your computer and uses the in-built sound card.&nbsp;
I prefer an external synth, because it runs independently of my music.&nbsp;
They run through different channels, and I can control them independently.&nbsp;
I turn up the music when I am taking a break, and I turn down the music when I have to think.&nbsp;
But a software synth has distinct advantages too.&nbsp;
It does not require a serial port (some computers don't have these ports any more),
and I don't really want to carry a hardware synth and cables with me when I am on the go.&nbsp;
That kinda defeats the purpose of a laptop.&nbsp;
Also, a software synth can be updated from time to time,
to fix bugs or improve the speech.&nbsp;
So there are pros and cons to these two approaches.

<P>
The hardware synths, or external synths, that are supported are shown by the usage message.&nbsp;
Type jupiter with no arguments to get the usage message.&nbsp;
After a few options, the first argument is the synthesizer.&nbsp;
Here are the supported hardware synthesizers.

<P>
dbe = doubletalk external
<br>
dte = dectalk external
<br>
bns = braille n speak
<br>
ace = accent

<P>
The second argument determines the serial port.&nbsp;
This is 0 through 3, for /dev/ttyS0 through /dev/ttyS3.&nbsp;
On my system I invoke `jupiter dbe 0' for the DoubleTalk synthesizer on /dev/ttyS0.

<P>
At some point I need to generalize the port parameter.&nbsp;
A computer without a serial port can still connect to an external synth using a usb to serial converter.&nbsp;
However, the name of the serial device might not be /dev/ttyS0.&nbsp;
More research is needed here.

<P>
The only software synthesizer currrently supported is espeak,
although espeak comes in a variety of languages.&nbsp;
(Most of the external synths are English, or perhaps English and Spanish.)&nbsp;
Jupiter connects to espeakup through a pipe, sending text to be spoken,
and receiving index markers in return.&nbsp;
Once again jupiter is invoked with two arguments.&nbsp;
The first is esp, for espeakup, and the second is the command to launch espeakup.&nbsp;
On my system it looks like this.

<P>
jupiter esp "|espeakup -V en-us+klatt4 -a 2>/dev/null"

<P>
espeakup is the program to run, and even though it launches and operates correctly,
it generates error messages, which is why standard error is sent to /dev/null.&nbsp;
The -V option specifies the language and the voice,
in this case English, as pronounced in the United States,
using the male voice klatt4.&nbsp;
Finally the -a option tells espeakup to operate through a pipe,
as required by Jupiter,
and that's where we run into trouble.&nbsp;
The distributed version of espeakup doesn't recognize the -a option, and doesn't work with jupiter.&nbsp;
Instead, you must fetch the source from github and compile it yourself.

<P>
git clone https://github.com/williamh/espeakup

<P>
I really don't understand why the distributed binary does not behave exactly as the compiled source,
but there it is.&nbsp;
You can always test your system by:

<P>
echo "hello world" | espeakup -V en-us -a

<P>
Another quirk of espeakup is that it does not exit on broken pipe.&nbsp;
If jupiter exits for any reason, espeakup is still hanging around.&nbsp;
You need to killall espeakup to clean things up.

<H3 align=center> <A NAME=mod> Modules </A> </H3>

Any program can read screen memory from /dev/vcs,
but how do you get your hands on tty output
as it is being generated?&nbsp;
How do you intercept these output characters and store them in a buffer for review?&nbsp;
The answer is a new device driver called /dev/acsint.&nbsp;
Jupiter opens this device driver, and has access to all tty output,
and to the keystrokes that implement speech commands.&nbsp;
In other words, /dev/acsint is the connector between Jupiter and the Linux kernel.

<P>
You must compile and install two modules to bring /dev/acsint to life.&nbsp;
These modules are ttyclicks.ko and acsint.ko.&nbsp;
Unfortunately I can't distribute these modules in binary,
because a new module must be compiled for each kernel version.&nbsp;
Run `uname -r' to see your kernel version.&nbsp;
If yours is 3.12.3.2, and mine is 3.12.3.1, then my modules won't run on your kernel, and vice versa.&nbsp;
This is intentional,
to prevent the accidental assembly of an inconsistent kernel, but it sometimes gets in the way.&nbsp;
Thus you have to build these modules yourself.&nbsp;
And that means you have to have the source for your kernel, which is often available as part of your distribution,
but is rarely loaded onto your computer.&nbsp;
After all, most people don't build the kernel or kernel modules.&nbsp;
But you may have to, as part of the Jupiter installation process,
so make sure you have the source for your running kernel.&nbsp;
Then descend into the drivers directory in the acsint package and type `make modules'.&nbsp;
Then as root, type `make modules_install'.&nbsp;
If these two steps run without error, run `depmod -a'.&nbsp;
This tells the modprobe system about the two new modules that you just built.&nbsp;
You will be able to load them into the kernel at any time,
and of course you will want to load them very early in the boot sequence,
because Jupiter will not run without them.&nbsp;
I have this near the top of /etc/rc.sysinit.

<P>
modprobe acsint

<P>
That brings in the acsint module, and the ttyclicks module, since the former depends on the latter.&nbsp;
See /lib/modules/version/modules.dep for module dependencies.&nbsp;
With acsint loaded, we are ready for Jupiter -
with a few caveats that will be described below.

<P>
There is no harm in installing and running ttyclicks and acsint, whether you use Jupiter or not.&nbsp;
They will not interfere with Speakup, or other adapters, or other running programs.&nbsp;
So just let them run all the time.

<P>
You'll notice that ttyclicks
generates clicks as output is sent to the screen.&nbsp;
This is exactly what it is suppose to do;
it is the primary function of the ttyclicks module.&nbsp;
This can be extremely helpful, especially if your adapter is not running for any reason.&nbsp;
I can tell, by clicks alone, when the computer responds to a command,
and I can discern the quantity and format of that response,
without any speech or braille.&nbsp;
In addition, the output is throttled, and does not fly by the screen
faster than I could possibly hit control S.

<P>
It is important that this be a separate, stand alone kernel module,
apart from anybody's adapter.&nbsp;
If the adapter isn't running,
if the synthesizer isn't working, if the braille display isn't working,
if we're talking to the wrong serial port, if the sound card isn't working,
if the sound card is not properly initialized,
if the sound module is not loaded, if the wrong sound module is loaded,
if an essential daemon is not running - at least I have my clicks.&nbsp;
I can tell, to some degree, what the computer is doing.&nbsp;
If it gets to a login prompt, I know what that sounds like.&nbsp;
I can log in and listen for the single click of the $ prompt,
which tells me I have a shell.&nbsp;
Then I can issue some basic commands,
trying to load modules and start the adapter.&nbsp;
All this I do without speech.&nbsp;
I need these clicks to be present whenever Linux is running.&nbsp;
To this end, ttyclicks is a self-contained module
that is loaded first in the boot sequence.&nbsp;
I can turn off the clicks at run time if I wish,
but if the synthesizer ever fails me for any reason,
I have the clicks to fall back on.

<P>
As you can see from the above paragraph,
I don't want to run these clicks through anybody's sound card.&nbsp;
There are too many points of failure along that path.&nbsp;
Instead, I use the in-built toggle speaker at port 0x61.&nbsp;
Not all computers have this speaker, but most do,
and I wouldn't buy one that didn't.

<P>
Other programs, outside of the linux kernel, can also take advantage of
this legacy speaker.&nbsp;
Grub, for instance, beeps when it brings up the menu,
provided I put a control G in the first title in grub.conf.&nbsp;
This tells me that I have ten seconds to cursor up and down
and select a target, if I want something other than the default.&nbsp;
Beyound this, it tells me that the machine has gotten to grub successfully,
and is not stuck in bios for some bizarre reason.&nbsp;
Thus a multi-boot system becomes practical.&nbsp;
It is difficult to overstate the importance of this little in-built speaker
for the blind user.

<P>
This module might not click and chirp if you are in X.&nbsp;
It responds to text characters that pass through the standard tty,
and as mentioned earlier, X bypasses this channel.&nbsp;
Even the terminal emulator running under a desktop still runs through X,
and probably won't work with ttyclicks.&nbsp;
You really need to be at run level 3.&nbsp;
See /etc/inittab for the run level.&nbsp;
The ttyclicks module is for command line users,
or users who will stay in command mode long enough to make sure their
software is properly launched and speaking.

<P>
If an output character is an echo of what you typed in, and if it is in upper case, you will hear a high beep instead of a click.&nbsp;
This confirms the fact that you have entered a capital letter.&nbsp;
Thus you receive immediate audio feedback if caps lock is on.&nbsp;
It is quite common for me to hit caps lock by mistake, but I know that it has happened, thanks to the high beeps,
and I hit caps lock again to return to standard typing.&nbsp;
All this audio feedback is at your disposal as long as ttyclicks is installed, whether you run Jupiter or not.

<P>
The clicks have one drawback however;
while output is being generated they monopolize the cpu.&nbsp;
It is hard for other processes to run.&nbsp;
You may find that your music pauses
when a program generates a lot of output.&nbsp;
There is a two step fix for this.&nbsp;
The first step is a patch to the kernel.&nbsp;
See click-sleep.3.12.3.patch in the patch directory of the acsint project.&nbsp;
If you are able to patch and rebuild and reinstall your kernel,
which is, sadly, not a trivial task, then the parameter sleep=1
enables ttyclicks to sleep between clicks, so that it does not take over the cpu.&nbsp;
Place this line in /etc/modprobe.d/access.conf, but only if you have patched the kernel as directed above.

<P>
options ttyclicks sleep=1

<P>
The acsint module also has an optional parameter, major=n, to set the major number of the device driver.&nbsp;
If a major number is not specified, then acsint registers a character device with major number 10 and a minor number that is chosen dynamically.&nbsp;
In practice the minor number is the same each time on your machine,
as long as acsint is loaded early in the boot sequence.&nbsp;
Thus it becomes predictable.&nbsp;
There are two ways to determine the minor number.&nbsp;
After acsint is loaded, tail /var/log/messages.&nbsp;
The log contains the registration of acsint as a character device, along with its minor number.&nbsp;
A better way is to look at
/sys/devices/virtual/misc/acsint/dev,
assuming /sys is mounted type sysfs.&nbsp;
In fact, Jupiter reads this file to see if perhaps /dev/acsint was created with the wrong major or minor numbers.&nbsp;
If /dev/acsint is missing, or if it has numbers different from its corresponding file under /sys,
Jupiter tries to remove it and recreate it.&nbsp;
I am doing everything I can to make sure the system comes up talking.&nbsp;
And yet there are still speedbumps.&nbsp;
At startup, /dev is mounted readonly, so I can't make any changes to it.&nbsp;
One way around this is to start udev first.&nbsp;
Then /dev becomes a virtual file system that is writable.&nbsp;
But bear in mind, I want Jupiter to start speaking as soon as possible,
so I can read any error messages that might occur.&nbsp;
Starting a lot of other services before Jupiter is not ideal,
but we don't always have a choice.&nbsp;
As mentioned above, starting udev before Jupiter might make sense.&nbsp;
Beyond this, you have to install acsint, and your sound card modules, or Jupiter won't talk at all.&nbsp;
Thus the order of commands in /etc/rc.sysinit is something like this.

<P>
#  Get the clicks running right away, so you have some audio feedback.
<br>
modprobe acsint
<br>
#  If you are using a software synth, get the sound card ready.
<br>
modprobe sound
<br>
sleep 1
<br>
/sbin/alsactl init 0 >/dev/null 2>&1
<br>
aumix -v 60 -w 100 -c 100 -p 50
<br>
#  Optionally start udev, and perhaps that will create /dev/acsint for you.
<br>
mount /sys
<br>
/usr/local/bin/jupiter -d esp "|espeakup -V en-us -a 2>/dev/null"

<P>
If you don't start udev at this point, or if you don't use udev at all,
then /dev/acsint should be in place on your system,
with major 10 and minor 59, or whatever minor number comes up on your system,
or perhaps with major 11 minor 1 if you put this line
in /etc/modprobe.d/access.conf

<P>
options acsint major=11

<H3 align=center> <A NAME=modes> Modes </A> </H3>

Jupiter has several modes that are on or off, enabled or disabled.&nbsp;
Bind these to function or control keys, and you can turn these modes on or off at will.&nbsp;
Most of these modes are global to all consoles.&nbsp;
For example, if autoread is on, then it remains on even if you switch from console 2 to console 8.&nbsp;
But some modes are per-console.&nbsp;
For instance, you may have an application running on console 9 that has to operate in screen mode,
while all the other consoles run happily in linear mode.&nbsp;
The modes are as follows.

<DL>
<P><DT>Sounds

<P>
<DD>
If it is the middle of the night and your roommate is asleep, you can disable all the chirps and clicks and beeps from the pc speaker.&nbsp;
This includes the clicks that accompany tty output,
and the short beeps that Jupiter uses to convy status or error conditions.&nbsp;
They can all be turned off in one go.

<P><DT>Clicktty

<P>
<DD>
If sounds are on, you can still disable the clicks associated with tty output.&nbsp;
That still leaves the beeps and tones that Jupiter produces for empty buffer, end of buffer, input error, toggle mode, etc.&nbsp;
Without clicktty, output is no longer throttled, and it flies across the screen at lightning speed.

<P><DT>Transparent

<P>
<DD>
In transparent mode, jupiter steps aside, as though it was not running at all.&nbsp;
Function keys pass right through, and it is not possible to read any text.&nbsp;
Also, the sounds are disabled.&nbsp;
Jupiter watches for one and only one keystroke, the one that turns transparent mode off
and brings Jupiter back to life.&nbsp;
You will hear three descending tones when transparent mode is enabled, as though Jupiter was stepping away,
then three ascending tones when transparent mode is turned off and Jupiter returns.&nbsp;
Text accumulates in the tty buffer even in transparent mode,
so you can see what happened while Jupiter was quiescent.

<P>
This mode runs per console.&nbsp;
Put console 1 in transparent mode and switch to console 2, and Jupiter is talking again.&nbsp;
Thus you could leave a console in transparent mode for your sighted friend.

<P><DT>Screen

<P>
<DD>
Jupiter reads tty output by default,
but in screen mode it will read the text from screen memory.&nbsp;
This is useful if a program uses curses to arrange text on the screen in a certain manner,
and you need to read it exactly as it appears on screen.&nbsp;
I try to avoid programs like this,
because (A) I don't like them, and (B) Jupiter is not as efficient in this mode.&nbsp;
The reading cursor does not stay with the text as it scrolls up or down,
and some international characters are misrepresented in screen memory.&nbsp;
Still, there are times when a screen program is the only game in town,
and in those situations you just have to play along.

<P>
Due to some hard compiled limits, screen mode will not work at all if the screen has more than 20,000 cells.&nbsp;
Jupiter will simply buzz for larger screens and remain in linear mode.&nbsp;
The largest screen I've run into so far is 48 by 170 = 8,160.

<P><DT>Oneline

<P>
<DD>
If oneline is enabled,Jupiter reads to the end of a line and then stops.&nbsp;
A line is delimited by newline in the tty buffer, or the edge of the screen if screen mode is enabled.&nbsp;
If oneline is disabled then Jupiter reads all the way to the end of the buffer or the end of the screen.&nbsp;
You may want to explicitly set or clear oneline mode in your reading commands.&nbsp;
If F3 reads the previous line, and F4 reads the next line,
they should perhaps set oneline mode to stop at the end of that line.&nbsp;
If F5 reads the rest of the screen or the rest of the buffer, it should clear oneline mode.&nbsp;
But it's up to you of course.

<P><DT>Autoread

<P>
<DD>
If the computer generates a new batch of output, jump to the end of the buffer and start reading the new output.&nbsp;
The word "new" here is subtle, and very important.&nbsp;
The computer may be cranking out 2 or 3 pages of output,
but I stopped reading because I want to review the exact words or letters in the first sentence.&nbsp;
As I am roaming around the buffer, reviewing the output, more output is added to the end of the buffer.&nbsp;
I don't want Jupiter to drag me down to the end of the buffer and start reading again.&nbsp;
I am busy elsewhere.&nbsp;
So autoread only comes into play if the output is new,
not related to the output I am already looking at.&nbsp;
But how, you may ask, does it determine whether the output is new?&nbsp;
As every comic knows, it's all in the timing.&nbsp;
If a burst of output occurs at least 0.4 seconds after the prior output, it is considered new output,
and autoread will take you down to the end of the buffer and start reading.&nbsp;
Conversely, if the output is less than 0.4 seconds after the prior output,
it is considered more of the same,
and Jupiter won't
take you away from what you are doing to read it, even if you are doing nothing at all.&nbsp;
Try it and see.&nbsp;
Cat a small file, and the clicks begin, and reading begins.&nbsp;
Hit the shutup key and reading stops, but the clicks continue, as output continues.&nbsp;
After the file is done, issue another command,
like echo hello world,
and reading begins with the new output.&nbsp;
This was tricky to program, but you know, it works pretty well.

<P>
If your system is under load, or if you are connected to a distant system via ssh, then 0.4 seconds may not be enough.&nbsp;
This parameter is hard coded in Jupiter, but some day I may make it a tunable parameter in the config file.

<P>
Autoread disables oneline mode.&nbsp;
If there is new stuff to read, and you're not busy reading other stuff,
and Jupiter pulls you down and reads the new stuff for you,
then you likely don't want to hear the first line only;
in fact the second line of the status message might be the important part.&nbsp;
So it makes sense to disable oneline mode at this point.&nbsp;
There is no trouble here,
because your next reading command will probably enable or disable oneline mode as part of its functionality.

<P><DT>Interrupt

<P>
<DD>
If interrupt is active, then any key will interrupt reading.&nbsp;
This is a mode you probably don't want.&nbsp;
I often type ahead, entering the next command while Jupiter is reading the prior output.&nbsp;
By default, Jupiter continues to read until a jupiter-bound key is entered,
that is, a key that causes Jupiter to take some action.&nbsp;
At that point Jupiter will stop reading.&nbsp;
This includes, of course, the shutup key.

<P><DT>Echo

<P>
<DD>
When echo mode is on, Jupiter echos the keys that you type.&nbsp;
These are the primary keys, alphanumeric and punctuation.&nbsp;
Function keys and the like are not echoed, assuming they perform some function, either through Jupiter or through a running application.&nbsp;
Like the clicks, this is a confirmation of the character on screen.&nbsp;
Type an e, and you hear the e when the e comes back to you, perhaps from far away over ssh.

<P>
This is primarily for people who aren't confident in their typing.&nbsp;
I find it distracting, and since echo mode implies interrupt mode,
it prevents any type-ahead, which slows me down even further.

<P>
For you international folks, this feature doesn't work with accented letters.&nbsp;
The &ntilde; that comes back on screen doesn't match n, the last key you typed, and so there is no echo.&nbsp;
This could be addressed, but it's not a high priority,
since echo mode is rarely used.

<P><DT>Literal

<P>
<DD>
When literal mode is on, all punctuation marks are read.&nbsp;
Programmers typically run with literal mode enabled, because every comma, every semicolon, might be important.&nbsp;
When literal mode is off, punctuation marks are passed directly to the synthesizer,
as though you are reading a story.&nbsp;
A smart synthesizer will pause for a comma, paus and lower pitch for a period, and pause and raise the pitch for a question mark.&nbsp;
However, even when reading English text, I usually leave literal mode on.&nbsp;
I have become accustom to hearing commas and periods spoken,
and in my brain it almost has the same effect as the corresponding pauses.&nbsp;
Of course it isn't nearly as funny as Victor Borge's
Phonetic Punctuation.

<P><DT>Control Chars

<P>
<DD>
Control characters, other than newline, tab, and bell, are typically culled from the tty buffer.&nbsp;
If this mode is enabled, they are retained.&nbsp;
This is usually used for debugging.

<P><DT>Override Signals

<P>
<DD>
If the serial connection to your external synthesizer is suspect,
you can use this mode to override the cts and rts signals that are typically used for flow control.&nbsp;
In other words, we switch to software flow control using x-on and x-off.&nbsp;
This is used for debugging serial connections, and is rarely needed.

<P><DT>Debug

<P>
<DD>
When debug is enabled, status messages are written to /var/log/acslog.&nbsp;
This helps me debug the acsint system and the Jupiter adapter.&nbsp;
A typical user will never activate this mode.

</DL>

<P>
Function keys, control keys, or alt keys can be configured to set, clear, or toggle any of these modes.&nbsp;
Key bindings will be discussed later.&nbsp;
Some of these modes, like the oneline mode, are changed often,
and you may want a handy, unshifted key to toggle this mode.&nbsp;
Turn it off when you can sit back and read a page of text,
and turn it on when you have to concentrate on technical material, and you only want to hear one line at a time.&nbsp;
Another mode that changes frequently is clicktty.&nbsp;
Sometimes you want to hear all those clicks, and sometimes,
e.g. when there is a lot more output than you expected, you want to shut them off at the touch of a button.&nbsp;
Thus I use F9 to toggle oneline, and F10 to toggle clicktty.&nbsp;
Other modes are changed infrequently, and can be modified by key chords or key sequences.

<H3 align=center> <A NAME=cfg> Config Files </A> </H3>

At startup, Jupiter reads its key bindings, and loads its replacement dictionary,
from the file /etc/jupiter/start.cfg.&nbsp;
This can be changed using the -c option.&nbsp;
The syntax and semantics of the config file will be described later.

<P>
You can have many different config files in /etc/jupiter,
tailored to specific applications.&nbsp;
These can be loaded at run time.&nbsp;
You can type in the name of a file to load, or preset a key to load a given config file.&nbsp;
If a preset filename does not begin with a slash, it is taken relative to /etc/jupiter.&nbsp;
This is different from the -c option,
where the filename is taken relative to the current directory.&nbsp;
If you have 4 different config files in /etc/jupiter,
I'll call them foo1 through foo4,
and if you want the 4 function keys on the right to load these 4 files,
then your bindings will look like this.

<P>
F9 reload foo1
<br>
F10 reload foo2
<br>
F11 reload foo3
<br>
F12 reload foo4

<P>
These bindings should be the same in every config file, so you can switch between them in a consistent manner.&nbsp;
Of course other keys will differ, from one config file to another, in their placement and functionality;
else why would you have different config files?&nbsp;
Key bindings will be described later, after I have presented the atomic speech commands.

<H3 align=center> <A NAME=rc> The Reading Cursor and Atomic Commands </A> </H3>

The reading cursor is a location in the tty buffer (in linear mode),
or on screen (in screen mode),
that corresponds to the letters or words you are reading or would like to read.&nbsp;
This is independent of the visual cursor that is on the screen, where text is entered or modified.&nbsp;
thus you can read the text anywhere on the screen,
just as a sighted person might lift his eyes to read the text at the top of the screen,
or lower his eyes to read the status message at the bottom of the screen.&nbsp;
In linear mode the effect is even more pronounced.&nbsp;
You might wonder exactly what happened two hours ago,
when you typed in rm *.&nbsp;
Were you in the right directory?&nbsp;
Did you accidentally delete something important?&nbsp;
Use the search function to find rm * in the tty log,
then read the line before to see what directory you were in,
then read the line after to review the computer's response,
exactly as it took place
some two hours ago (assuming not a lot of output between then and now).&nbsp;
Other screen readers refer to this roaming about as "screen review".&nbsp;
Fair enough, but a bit misleading if you are in linear mode,
for then you are reading text out of the tty buffer and not off the screen.

<P>
Various atomic commands move the reading cursor about in the tty buffer or on screen.&nbsp;
These are not typically issued on their own.&nbsp;
Instead, they are often put together in a sequence, then bound to a key.&nbsp;
For instance, F2 might move the reading cursor to the start of a line and then read the character
at the beginning of that line.&nbsp;
This is two atomic commands put together to make one composite command, which is then bound to F2.&nbsp;
In this manner, relatively complicated commands can be built.&nbsp;
You could construct a command that reads the top line of the screen, then the third line,
then leaves the reading cursor at the end of the second line.&nbsp;
That is a bit contrived, but it illustrates what can be done.

<P>
Here is a list of the atomic commands that relate to the reading cursor.&nbsp;
Each command has a brief name, about 6 characters, that you will use in the config file,
followed by a description of what that command does.

<DL>
<P><DT>cursor:
<DD>
Move the reading cursor to the visual cursor on screen.&nbsp;
This is where the action is.&nbsp;
A composite command might go down to the bottom of the screen, read the status message,
then issue this command to return to the visual cursor.&nbsp;
This command has no effect in linear mode.

<P><DT>clbuf:
<DD>
Clear the buffer.&nbsp;
Now the buffer is empty.&nbsp;
This generates an error (beep) in screen mode.

<P><DT>sbuf:
<DD>
Place the cursor at the start of the buffer, or the upper left of the screen.&nbsp;
If the bufffer is empty you will hear a couple quick high beeps indicating a boundary condition.&nbsp;
The same sound occurs if you pull the cursor past the start of buffer, or push it past the end of buffer.

<P><DT>ebuf:
<DD>
Place the cursor at the end of the buffer, or the lower right of the screen.

<P><DT>sline:
<DD>
Place the cursor at the start of the current line.&nbsp;
In linear mode, lines are delimited by the newline character control J.&nbsp;
Unless control char mode is enabled,
Jupiter turns crlf into lf, so you don't have to worry about extra return characters (control M) cluttering up your tty buffer.

<P><DT>eline:
<DD>
Place the cursor at the end of the current line.&nbsp;
The cursor sits on the newline character that terminates the line.&nbsp;
In screen mode the cursor sits on a mythical newline character that Jupiter inserts for you.&nbsp;
Thus screen mode and linear mode have the same look&amp;feel.

<P><DT>sword:
<DD>
Place the cursor at the start of the current word.&nbsp;
A word is a sequence of alphanumerics (in your language), and at most one apostrophe,
or one unicode that is equivalent to an apostrophe, such as 0x99.&nbsp;
Thus ni&ntilde;o looks like one word in Spanish, but three words in English.&nbsp;
As mentioned earlier, Jupiter uses $LANG to determine your language.&nbsp;
Hello3world is one word in any language.&nbsp;
Many variables in computer programming, or in math, are a mix of letters and numbers,
and it is convenient to treat these as compound words.

<P><DT>eword:
<DD>
Place the cursor at the end of the current word.

<P><DT>lspc:
<DD>
Move the cursor to the left through spaces,
stopping at the last space.&nbsp;
If there are no spaces to the left of the cursor then it remains in position.&nbsp;
This command should perhaps skip past higher unicodes that are equivalent to a space, such as 0xa0.&nbsp;
That is still under consideration.&nbsp;
As you might imagine, this is rarely used on its own.&nbsp;
Rather, it is used in sequence, to skip past whitespace and read the next word for example.

<P><DT>rspc:
<DD>
Move the cursor to the right through spaces,
stopping at the last space.&nbsp;
If there are no spaces to the right of the cursor then it remains in position.

<P><DT>back:
<DD>
Move the cursor back one character.

<P><DT>for:
<DD>
Move the cursor forward one character.

<P><DT>prow:
<DD>
Move the cursor up one row.&nbsp;
Sound an error if there is no previous row, or if the previous row is too short
to remain in your current column.&nbsp;
Obviously this latter condition cannot occur in screen mode, since all rows are the same length.

<P><DT>nrow:
<DD>
Move the cursor down one row.

<P><DT>lcline:
<DD>
Put the cursor at the start of the last complete line.&nbsp;
This is meant to read the last line of output, just before the prompt.&nbsp;
In screen mode the cursor is at the start of the second to last line,
assuming the last line is a prompt.

<P><DT>column:
<DD>
Read the current column number.&nbsp;
The first character in a line is in column 1.&nbsp;
Remember that lines can be very long in linear mode.&nbsp;
A series of dots, indicating progress in a file transfer,
could create a line that is hundreds or thousands of characters long.

<P><DT>char:
<DD>
Read the current character.&nbsp;
A letter or digit is simply passed to the speech synthesizer.&nbsp;
Control G sounds the bell if sounds are enabled,
or says the word bell if sounds are disabled.&nbsp;
Control J issues a quick swooping sound that is specific to newline, if sounds are enabled,
or says the word newline if sounds are disabled.&nbsp;
Other control characters are typically culled from the buffer.&nbsp;
If control K is present however, it is read as "control K".&nbsp;
A punctuation mark is read using a default word or phrase,
unless you override its pronunciation in your config file.&nbsp;
The symbol ! might be read as exclamation point,
but you may prefer the shorter word bang.&nbsp;
Finally a higher unicode is spoken as directed by your config file,
or it is simply said as the word code followed by the unicode in hex.&nbsp;
If you do math, for instance, you may want to set the pronunciations of the Greek letters and the math symbols in your config file.

<P><DT>capchar:
<DD>
This is the same as char, but a capital X is read as "cap X", rather than simply x.

<P><DT>asword:
<DD>
This is the same as char,
but a letter is read as a word, using the nato alphabet.&nbsp;
This is used to distinguish between similar sounding letters such as m and n.&nbsp;
The former is read as Mike, and the latter as November.&nbsp;
An accented letter is downshifted to its unaccented version, then read as a nato word in that language.&nbsp;
Thus &#243; in Portuguese is read as Oscar.

<P><DT>word:
<DD>
Read the current word.&nbsp;
The entire word is read, even if the cursor is in the middle of the word.&nbsp;
The cursor is left at the end of the word.&nbsp;
To aid in pronuncibility, spaces are inserted at letter-digit or case boundaries.&nbsp;
ThusRedGreen3Blue is pronounced "red green 3 blue".&nbsp;
This is usually what you want.

<P><DT>read:
<DD>
Start continuous reading.&nbsp;
Jupiter will begin reading, and will not stop until you interrupt it,
or it reaches the end of a line and oneline mode is enabled.&nbsp;
The cursor tracks the words you are hearing.&nbsp;
Thus you can stop it at any time, using any of these commands,
and the cursor will be on the word you last heard.&nbsp;
If something doesn't sound right, stop reading and review the individual words and letters.&nbsp;
You can then resume reading at this point if you like.

<P><DT>shutup:
<DD>
Stop reading, but take no other action.&nbsp;
This leaves the cursor on or near the word you last heard.

<P><DT>label:
<DD>
This command waits for you to type a letter, then sets a label, using that letter,
at the current location in the buffer.&nbsp;
If you are at the start of the buffer you might issue this command, then type the letter t, to mark this as the top of the buffer.&nbsp;
That's rather silly, since there is already a start of buffer command, but I present it as an example.&nbsp;
Then jump t will take you back to this location.&nbsp;
This is primarily used in linear mode, where you may want to mark several locations in your tty buffer.

<P><DT>jump:
<DD>
Enter a letter and jump to the location in your buffer that was set using that letter.

<P><DT>markl:
<DD>
Mark this as the left edge of some text that you want to cut&amp;paste.

<P><DT>markr:
<DD>
Mark this as the right edge of some text that you want to cut&amp;paste.&nbsp;
You musst enter a follow-on letter, whence this block of text will be associated
with the alt of that letter.&nbsp;
You should probably leave most of your alt-letters unbound, so they can be used for cut&amp;paste.&nbsp;
As an example, put your cursor on the h in hello world and issue mark left.&nbsp;
Then move the cursor to the d in world and issue mark right, followed by h.&nbsp;
Now alt-h will generate "hello world", as though you had typed it in.&nbsp;
After you get use to using cut&amp;paste, you will become absolutely dependent on it.&nbsp;
I'm getting older, and can hardly remember a 7 digit phone number any more,
so I just use cut&amp;paste to copy it from one file to another.

<P><DT>searchd:
<DD>
Search down the buffer for a string of text.&nbsp;
Enter the string at the keyboard, using ascii only.&nbsp;
The search is case insensitive, and letters will match their accented counterparts.&nbsp;
There is no need to enter o umlaut (In German), just type o and it will match o umlaut.&nbsp;
If this is the last command in the sequence, and a match is found,
Jupiter will read the current line in oneline mode, or simply say ok otherwise.&nbsp;
Of course you can follow this up with other commands,
e.g. read the line just before the line that contains the phrase "oreo cooky".

<P><DT>searchu:
<DD>
Search up the buffer for a string of text.&nbsp;
The behavior is as above, except the cursor moves backwards rather thand forwards.

</DL>

<P>
While we're in the neighborhood, let's describe some other atomic commands.&nbsp;
As you recall, Jupiter runs in several different modes.&nbsp;
These modes can be set, cleared, and toggled using the
stmode, clmode, and toggle commands.&nbsp;
A follow-on letter determines the mode.&nbsp;
Thus stmode s sets screen mode, and clmode a clears autoread mode.&nbsp;
The letters and modes are as follows.

<P>
s screen mode versus linear mode
<br>
a autoread
<br>
n sounds (n is for noises)
<br>
t clicktty, clicks accompany program output
<br>
1 oneline mode
<br>
i interrupt speech with any key
<br>
e echo keys as typed
<br>
l literal reading of all punctuations
<br>
c control chars in buffer
<br>
o override rs232 signals, software flow control
<br>
d debug messages in /var/log/acslog

<P>
Most reading commands will start by setting or clearing oneline mode.&nbsp;
To read the next line, and only the next line, do this.

<P>
stmode 1 eline for read

<P>
To read from your current location to the end of the bufffer, do this.

<P>
clmode 1 read

<P>
Several atomic commands control the speech synthesizer.&nbsp;
Some of these may not be implemented, depending on your synthesizer.

<P>
The volume, speed, pitch, and voice can be set,
using the volume, speed, pitch, and voice commands.&nbsp;
Each command takes a follow-on digit from 0 to 9.&nbsp;
0 is the slowest speed and 9 is the fastest, and similarly for volume and pitch.&nbsp;
The voice command selects one of several voices, and then says "hello there",
so you can hear how the voice sounds.&nbsp;
However, this is only implemented for a couple of external synthesizers.&nbsp;
Yes, espeakup has several voices to choose from, but you cannot change them on the fly.&nbsp;
It is a -V option that is part of the espeakup command line.

<P>
Other commands increase or decrease these parameters as follows.

<P>
incvol increase volume
<br>
decvol decrease volume
<br>
incspd increase speed
<br>
decspd decrease speed
<br>
incpch increase pitch
<br>
decpch decrease pitch

<P>
It's nice to have some nearby keys to increase and decrease volume,
commensurate with the background noise of your surroundings.

<P>
Here are a few more system commands.&nbsp;
Like the synthesizer commands, these are run on their own,
and not combined into larger commands.

<DL>
<DT>bypass:
<DD>
What happens if F2 reads the current line, and yet you have to pass F2 to your running program?&nbsp;
The bypass command takes the next key and passes it through, as though it had no meaning.&nbsp;
This is rarely needed in linear mode,
except to pass control D through for EOF, and control C for interrupt.

<P><DT>bind:
<DD>
Read a text string from the keyboard and pass it to Jupiter as though it had come from the config file.&nbsp;
Thus you can change key bindings or pronunciations on the fly.&nbsp;
This is generally used for testing.&nbsp;
You should really keep your keyboard layouts and pronunciations in config files.

<P><DT>reexec:
<DD>
Restart the adapter.&nbsp;
This is for developers; after you havemade a change to the software you can restart the program with one button.&nbsp;
The same arguments are passed to the program.

<P><DT>reload:
<DD>
Reload a config file.&nbsp;
The name of the file is entered at the keyboard,
and is taken relative to /etc/jupiter, unless it begins with a slash.&nbsp;
Issue this command if you have made a change to your config file,
or you want to use another configuration
that is better suited to your application.&nbsp;
If the file cannot be found, or is unreadable,
Jupiter sounds the error bell and retains the preexisting configuration.

<P><DT>dump:
<DD>
Dump the current buffer, in utf8, to /tmp/bufn, where n is the number of your current console.&nbsp;
This is a snapshot of the tty log or screen memory.

<P><DT>suspend:
<DD>
Suspend the adapter.&nbsp;
Activate transparent mode, as described in an earlier section.

<P><DT>step:
<DD>
Play a chromatic scale on the pc speaker using parameters drawn froma file.&nbsp;
The name of the file is entered at the keyboard,
and is taken relative to /etc/jupiter, unless it begins with a slash.&nbsp;
The file contains 4 numbers separated by commas.&nbsp;
The first is a start frequency and the second is an end frequency.&nbsp;
The third is a geometric step, as measured in percent.&nbsp;
Thus 6 takes steps of 6%,
which produces a traditional chromatic scale.&nbsp;
A negative step gives a descending scale.&nbsp;
The fourth number is the duration of each note in hundredths of a second.&nbsp;
Here is a pretty sound.

<P>
8000,200,-10,40

</DL>

<P>
<A HREF=#top>Back to top</A>

</BODY></font>
