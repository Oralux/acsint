--- a/Documentation/accessibility/ttyclicks.txt	2014-12-01 21:48:42.556016496 -0500
+++ b/Documentation/accessibility/ttyclicks.txt	2014-12-01 21:48:42.560017026 -0500
@@ -0,0 +1,160 @@
+
+The tty clicks module
+			---------------------
+			Karl Dahlke
+			eklhad@gmail.com
+
+When this module is installed, soft clicks accompany
+the nonspace characters that are sent to the console,
+while a longer swoop indicates a newline character.
+These sounds simulate an old fashion teletype (how many of you are old enough
+to remember those) running at 2400 baud.
+Why would you want such a thing?
+You probably wouldn't, but a blind person might.
+
+I can tell, by clicks alone, when the computer responds to a command,
+and I can discern the quantity and format of that response,
+without any speech or braille.
+In addition, the output is throttled, and does not fly by the screen
+in a flash, faster than I could possibly hit control S.
+
+It is important that this be a separate, stand alone kernel module
+that does not depend on anything else.
+If the adapter isn't running,
+if the synthesizer isn't working, if the braille display isn't working,
+if we're talking to the wrong serial port, if the sound card isn't working,
+if the sound card is not properly initialized,
+if the sound module is not loaded, if the wrong sound module is loaded,
+if an essential daemon is not running - at least I have my clicks.
+I can tell, to some degree, what the computer is doing.
+If it gets to a login prompt, I know what that sounds like.
+I can log in and listen for the single click of the $ prompt,
+which tells me I have a shell.
+Then I can issue some basic commands,
+trying to load modules and start the adapter.
+All this I do without speech.
+I need these clicks to be present whenever the kernel is running.
+To this end, ttyclicks is a self-contained module
+that is loaded first in the boot sequence,
+quite apart from any adapters.
+I can turn off the clicks at run time if I wish,
+but if the synthesizer ever fails me, for any reason,
+I have the clicks to fall back on.
+
+As you can see from the above paragraph,
+I don't want to run these clicks through anybody's sound card.
+There are too many points of failure along that path.
+Instead, I use the in-built toggle speaker at port 0x61.
+Not all machines have this speaker, but most do,
+and I wouldn't buy a computer that didn't.
+
+Other programs, outside of the linux kernel, can also take advantage of
+this legacy speaker.
+Grub, for instance, beeps when it brings up the menu,
+provided I put a control G in the title.
+This tells me that I have ten seconds to cursor up and down
+and select a target, if I want something other than the default.
+Beyound this, it tells me that the machine has gotten to grub successfully,
+and is not stuck in bios for some bizarre reason.
+It is difficult to overstate the importance of this little in-built speaker
+for the blind user.
+
+This module might not click and chirp if you are in X.
+It responds to text characters that pass through the standard tty,
+and probably doesn't do anything in graphics mode.
+Even the terminal emulator, running under a desktop, still runs through X,
+and probably won't work with ttyclicks.
+You really need to be at run level 3.
+See /etc/inittab for the run level.
+This module is for command line users,
+or users who will stay in command mode long enough to make sure their
+software is properly launched and speaking.
+
+Module parameters:
+
+As always, you can run modinfo ttyclicks.ko to review these parameters.
+
+enabled = 1 or 0
+
+If 1, then sounds are enabled as soon as the module is loaded.
+If 0, then sounds are not enabled.
+These sounds can be turned on or off at run time by the exported symbol
+	bool ttyclicks_on;
+Thus other modules can turn sounds on or off.
+In particular, any adapter that includes a lodable module
+has access to this master switch.
+
+fgtty = 1 or 0
+
+This parameter enables the clicks that accompany the display of characters
+from  the foreground tty.
+The corresponding exported symbol is
+	bool ttyclicks_tty;
+
+kmsg = 1 or 0
+
+Printk messages do not pass through the tty,
+and do not generate the aforementioned clicks.
+However, if this switch is enabled,
+each printk message generates a distinctive sequence of tones.
+This is like an alarm,
+telling the user that he needs to read the message on the screen.
+The corresponding exported symbol is
+	bool ttyclicks_kmsg;
+
+cursormotion = 0 or 1
+
+Many screen programs generate ansi escape sequences that position the cursor
+and set character attributes such as underline etc.
+This is not true output, and does not generate clicks by default.
+However, you can set this parameter to 1 if you want these characters
+to generate clicks.
+
+Exported functions.
+These are all subject to the master switch ttyclicks_on.
+
+void ttyclicks_click(void);
+
+Generate a 0.6 millisecond pulse.
+
+void ttyclicks_cr(void);
+
+Generate a quick frequency swoop from 2900 to 3600 hz.
+This sound is associated with the newline character at the console,
+but you can use this function to generate the same sound whenever you wish.
+
+void ttyclicks_notes(const short *notelist);
+
+Play a series of notes in the background.
+Each note is defined by two shorts, a frequency and a duration.
+The frequency is in hurtz, and the duration is in hundredths of a second.
+A frequency of -1 is a rest.
+A frequency of 0 terminates the array.
+The queue can only hold 64 notes, so don't try to play an entire sonata.
+
+void ttyclicks_steps(int freq1, int freq2, int step, int duration)
+
+Play a series of notes, of the specified duration, moving from
+frequency freq1 to frequency freq2 in a geometric progression of step%.
+This is a customizable chromatic scale.
+The traditional scale, based on half tones, and starting at middle C,
+has an approximate step of 6%, and looks like this.
+ttyclicks_mksteps(260, 530, 6, 150);
+Use a negative step for a descending scale.
+
+void ttyclicks_bell(void);
+
+This function generates an 1800 hz tone for a tenth of a second.
+this is associated with the control G bell.
+The traditional bell is 1000 hz, but I wanted a slightly higher tone.
+As long as this module is loaded, it swallows control G, and sounds the bell,
+rather then passing it through to the console and letting the console
+ring the bell.  This allows the master switch, ttyclicks_on,
+to enable or disable the control G bell along with all the other sounds.
+You can turn off all the sounds in one go, if they are bothering your roommate.
+
+This module is integral to many command line adapters,
+as a complement to speech or braille.  Beyond this,
+it can prove invaluable if the adapter is not working for any reason.
+I have relied on this form of audio feedback, in some form or another,
+for over 30 years.
--- a/Documentation/accessibility/acsint.txt	2014-12-01 21:48:42.564017556 -0500
+++ b/Documentation/accessibility/acsint.txt	2014-12-01 21:48:42.567017954 -0500
@@ -0,0 +1,526 @@
+
+The acsint device driver
+			---------------------
+			Karl Dahlke
+			eklhad@gmail.com
+
+The word acsint is shorthand for accessibility intercepter,
+since we are going to intercept kernel events and make the linux computer
+more accessible to a wide range of disabilities.
+The concept was developed by Saqib Shaikh in 2005, but did not
+become practical until notifiers came on the scene in kernel 2.6.26.
+Before then, many large and complex screen readers,
+such as Speakup, were either built into the kernel,
+or written as kernel modules that run in kernel space.
+This makes it difficult to drive software synthesizers,
+which are large and complicated programs that must run in user space.
+The advantages of pulling screen readers and other adapters
+out of the kernel and back into user space are simply to numerous to mention.
+You can probably think of 5 off the top of your head.
+The acsint system makes it possible to write an adapter as a user space daemon,
+and still adapt the computer at the lowest level.
+
+Acsint is a linear system, passing keystrokes and tty output
+to user space through a virtual stream.
+In other words, it is well suited to the command line interface.
+This does not form the basis for adapting gnome, kde, X,
+or any other 2 dimensional screen / graphical presentation.
+People are working on adapters for those systems, e.g. Orca for gnome.
+Acsint is for the command line interface,
+which is (not surprisingly) what I prefer.
+
+Acsint provides low level kernel events which are described below.
+However, managing these events is a bit like reading a block device
+without a filesystem on top of it.
+You can do it, but you probably don't want to.
+I have developed a user space library called acsbridge,
+which is a layer above this device driver.
+Continuing our earlier analogy, this is the filesystem on top of the block device.
+The bridge layer gathers events from the driver and maintains a running log
+of all tty output.
+It tells the driver which keys to capture (dynamic key binding),
+and then notifies the adapter, via callback functions,
+when those keys are struck.
+The operation of the acsint bridge layer is beyond the scope of this document.
+I just wanted you to know that a higher level API exists,
+and if you are building an adapter, you probably want to use that library,
+rather than reading from this driver directly.
+
+This is not just a pencil and paper sketch -
+adapters have been written successfully using this system.
+In other words, it really works.
+I am in such an adapter right now, as I write this file.
+It is a user space program, using the acsint bridge layer
+to gather events from /dev/acsint.
+My adapter lived in the kernel for 10 years,
+but I was more than happy to pull it back down to user space.
+Little was lost, and much was gained.
+For instance, just last week a bug in my software caused a seg fault,
+not a kernel panic.
+What more can I say?
+
+Acsint is written as a loadable kernel module,
+though it could be built into the system.
+As a module, it has one parameter, "major",
+which is the major number of the resulting device.
+
+modprobe acsint major=11
+
+When called this way, you will want to create /dev/acsint
+with major number 11 and minor number 1.
+
+modprobe acsint major=0
+
+If major is set to 0, or left unspecified,
+we use misc_register() to instantiate a device dynamically.
+The device will have major number 10 and minor number to be determined.
+If udev is running on your system, it can create /dev/acsint
+for you having the correct major and minor numbers.
+Thus your user space adapter can open the device and gain access
+to kernel events.
+
+The device offers the functions open, close, read, write, and poll.
+In this regard it is much like any other character device.
+One could imagine other drivers that offer the same functionality
+through these 5 system calls, but that is beyond the scope of this document.
+Here is a rough outline of these 5 system calls.
+
+open()
+
+Only one program can open this device at a time.
+If the device is already opened, -1 is returned,
+with errno set to EBUSY.
+Other than that, the open will succeed.
+An initial event is placed on the read queue,
+to tell the adapter what console it is running on.
+See the FGC event below.
+Thus, if you read from the device, you will get an event right away.
+
+close()
+
+This closes the device.
+The busy flag is cleared, and the next call to open() will succeed.
+All internal buffers are cleared, and all variables reinitialized.
+There is no memory of accumulated tty output, or key bindings, etc.
+Each open starts a brand new session.
+
+poll()
+
+The adapter can poll the device to see if it has any events to read.
+This is used by the adapter, or the bridge layer,
+to monitor two devices at once, the acsint driver and the speech synthesizer.
+(See the select system call.)
+The synthesizer could be attach to a serial or usb port,
+or a socket, or a pipe - but it is probably accessible via a file descriptor,
+which means we want to read from two descriptors simultaneously.
+That is done with select(), and that requires a polling function.
+You probably don't need to invoke poll() directly -
+let select() do the work for you.
+
+write()
+
+This is used by the adapter to configure the driver.
+Most commands are 1 2 or 3 bytes long.
+The first byte is the action,
+and the following bytes are parameters for that action.
+
+char acsint_command[4];
+acsint_command[0] = ACS_SOME_ACTION;
+acsint_command[1] = some_parameter;
+write(acsint_fd, acsint_command, 2);
+
+The driver swallows the command immediately, and acts upon it.
+There is no reason this write should fail.
+Of course the action, or its parameter, could be invalid for some reason,
+but the write() system call still succeeds, and returns 0.
+
+The configuration commands are defined in linux/acsint.h.
+The application should include this header file
+and use the symbolic constants therein.
+The write actions are as follows.
+
+ACS_BUFSIZE
+
+Set the size of the tty log buffer in user space.
+The driver passes this many characters down to user space in one system call.
+(See read below.)
+Two bytes build an unsigned short, which is the size of the buffer.
+Thus this is a 3 byte command.
+The default size is 256, which is pretty small,
+so you probably want to issue this command as soon as you open the device.
+
+ACS_CLEAR_KEYS
+
+Clear all key bindings.
+All keystrokes are passed through to the console.
+None are intercepted for the adapter.
+
+ACS_SET_KEY
+
+The parameters are the key code and the shift state.
+thus this is a 3 byte command.
+Key codes can be found in linux/input.h, which is included by acsint.h.
+If you issue this command with KEY_F1 and ACS_SS_CTRL, then control F1
+is intercepted and passed back to your adapter
+via the read() system call described below.
+It does not become input for the foreground tty.
+You can put states together to capture key chords.
+For instance, ACS_SS_LALT|ACS_SS_CTRL will capture
+the key when modified by the left alt and the control keys simultaneously.
+Any combinations not specifically intercepted will pass through to the console.
+
+The additional bit ACS_KEY_T will cause the key to tee back to your adapter
+and to the console. This is typically used to stop any reading in progress,
+and send the key to a running program, which you expect to produce
+new output that you want to hear.
+
+ACS_UNSET_KEY
+
+The parameters are the key code and the shift state.
+This reverses the action of ACS_SET_KEY above.
+The key, with the specified modifiers, is no longer intercepted,
+and will pass through to the console.
+
+ACS_ISMETA
+
+This takes a key code and a shift state. If the shift state is nonzero,
+the key becomes a meta key, like shift or alt etc.
+Holding it down has the same effect as holding down the original modifier(s).
+For example, Speakup uses the insert key to modify other keys.
+To simulate this, call acs_ismeta(KEY_INSERT, ACS_SS_RALT);
+You can then bind various speech functions to right alt keys,
+and use the insert key for right alt.
+
+ACS_PUSH_TTY
+
+This function passes a string from user space back to the kernel,
+as though it had been typed at the keyboard.
+an adapter typically generates input for two reasons.
+1. A key can be a macro for a commonly used string,
+something that you don't want to type over and over again.
+2. A key can be bound to a string dynamically to support cut&paste.
+Mark the start and end of a string in the buffer, grab it,
+then inject it into the input stream of this console or another console.
+(I typically cut&paste between two consoles.)
+
+The command consists of the action code and the low and high bytes of an unsigned short.
+Thus ACS_PUSH_TTY 2 1 is pushing a string of length 258.
+The next 258 bytes form the string.
+The string can be utf8 to push international text into the console.
+
+ACS_BYPASS
+
+The driver will pass the next keystroke through to the console,
+even if it would normally be intercepted.
+If control C is bound to a speech function,
+but you want to pass control C through to the console to interrupt a
+running program, then you need this function.
+
+In theory there is a race condition here;
+the adapter could be swapped out, and you might type the next key
+before the BYPASS event was registered.
+In that event the next key will be intercepted as usual,
+and perhaps the key after that will pass through.
+The kernel isn't going to crash or anything,
+you'll just be a bit confused.
+
+ACS_DIVERT
+
+This takes the parameter 1 or 0, enabled or disabled.
+If enabled, all keystrokes are intercepted.
+Use this to type a short message directly into your adapter.
+For instance, type a search string into the adapter,
+then locate that text within the tty buffer.
+Don't forget to turn DIVERT off once the text has been entered,
+to resume normal operations.
+
+ACS_MONITOR
+
+This takes the parameter 1 or 0, enabled or disabled.
+If enabled, keystrokes that are destined for the console
+are also passed back to the adapter.
+Think of this as /usr/bin/tee.
+This could be used to echo keystrokes as they are typed,
+but in practice it is better to echo the characters as they appear on screen.
+Thus passwords are not echoed for the world to hear, etc.
+Most adapters do not use this function for echo.
+(See the MORECHARS event below.)
+Still, you may want to monitor keystrokes
+for some other reason that I haven't anticipated,
+and this function makes it possible.
+
+ACS_SOUNDS
+
+Acsint is capable of generating diagnostic clicks and chirps through
+the inbuilt toggle speaker at port 0x61.
+This is particularly helpful if speech is not working for any reason.
+Even if everything is operational, the clicks tell the user when the computer
+is generating output, and the nature of that output, before the synthesizer
+has spoken a word.  Most people find this audio feedback helpful.
+
+This function turns sounds on and off.
+If you are working in the middle of the night in a small dorm room,
+and your roommate is trying to sleep,
+well, you probably want to turn all sounds off.
+The one byte parameter is 1 or 0, for sounds enabled or disabled.
+
+Sounds are produced by the module ttyclicks.c.
+If depmod has been run, modprobe should load ttyclicks before it loads acsint.
+The ttyclicks module has some features that are not accessible
+through the acsint driver.  They are not described here.
+See ttyclicks.txt for more details.
+For our purposes we can pretend like acsint is generating the sounds itself.
+
+ACS_SOUNDS_TTY
+
+This takes the parameter 1 or 0, enabled or disabled.
+If enabled, then tty output produces clicks for printable characters,
+pauses for spaces, and a special swoop for newline.
+Blank lines, text, C code, columated data - all have distinct audio signatures.
+This does not pass any events back to user space, it simply generates
+clicks as characters pass through the tty and onto the screen.
+
+Note that sounds must be enabled overall, via ACS_SOUNDS, for this to work.
+SOUNDS is a master switch that turns all other sounds on or off.
+
+ACS_SOUNDS_KMSG
+
+This takes the parameter 1 or 0, enabled or disabled.
+If enabled, then printk messages produce a special,
+some would say irritating, sequence of tones.
+This is like an alarm for a blind person.
+"Hey, the kernel just printed an error message, you might want to read it."
+
+ACS_CLICK
+
+The driver clicks the speaker,
+as though a single character had appeared on screen.
+If the adapter accepts a hot key, and performs a function accordingly,
+a soft click can provide helpful audio feedback.
+"Yes I caught your keystroke, and all is well."
+Or you may want to issue several clicks in succession
+to convey some information to the user.
+Perhaps a sound like static, indicating a bad serial connection,
+and thus no speech.
+
+ACS_CR
+
+Generate the swoop that is associated with the newline character.
+(This was orriginally tied to cr, not lf,
+so is called acs_cr for historical reasons.)
+You may want to issue this sound when the user hits enter to complete
+a command that is directed towards the adapter rather than standard input.
+Or it can be used to indicate success.
+I use it when reading through text, because I would rather hear
+a quick swoop than the word "new line".
+I have an implicit understanding of where the lines break as I listen to the words.
+
+ACS_SWOOP
+
+Issue a frequency sweep from one level to another,
+either ascending or descending.
+The first byte is an unsigned char, and is multiplied by 10 to give
+the starting period.
+The second byte is multiplied by ten for the ending period.
+The third byte is a signed char, and represents the step.
+The function does this:
+
+for(period=start; period </> end; period += step) {
+	udelay(period);
+	toggle the speaker;
+}
+
+The ACS_CR function is shorthand for
+ACS_SWOOP 26 6 -2
+
+ACS_NOTES
+
+This command plays a series of notes, a song if you will.
+The notes are of course square waves, and not terribly melodic.
+The driver queuees up at most 10 notes to play; subsequent notes are discarded.
+
+The first parameter is a single byte indicating the number of notes.
+
+Each note is defined by three bytes.
+The first two bytes build a short, which is the frequency in hurtz.
+A frequency of -1 is a rest.
+The third byte is the duration in hundredths of a second.
+The standard control G bell, 1Khz for a tenth of a second, looks like:
+ACS_NOTES 1 232 3 10
+
+ACS_REFRESH
+
+This is the last write command, and it has no parameters.
+It is a request to bring the tty buffer in user space up to date.
+Let me clarify by describing the internals of the driver.
+
+In an early version of this driver, which was quickly shelved,
+each tty character generated an event.
+Cat a megabyte file, and millions of events passed through
+acsint and down to user space.
+If there was even a modest load on the system, the adapter could not keep up.
+Events were lost, and the adapter did not have an accurate
+representation of the characters on the screen.
+A new approach was needed.
+
+acsint maintains a circular buffer of size 50K for each virtual console.
+These buffers are allocated as needed.
+After all, 63 consoles are possible, but most systems only use 6.
+Tty output is placed at the head of the buffer, and if the buffer is full
+the oldest characters drop off the tail.
+Your adapter should maintain a 50K buffer for each active console,
+which will act as a mirror for the buffers in kernel space.
+The refresh command asks the driver to pass down any new output characters
+that have not been  seen before.
+These characters are transferred in one system call,
+and thus your read buffer should be at least 50K.
+(The actual size is a symbolic constant in acsint.h.)
+Once these characters are passed to user space, acsint places a mark
+at the head of the circular buffer, to remember where it left off.
+Issue the refresh command again,
+and you will get any new output characters beyond this mark.
+
+What happens if you cat a megabyte file?
+The flood of output pushes all the old characters,
+and the mark, off the tail of the buffer.
+The buffer now contains the last 50K of output.
+When you refresh, acsint passes this text down to user space,
+and your adapter will push it onto the parallel buffer that
+you are maintaining.
+Old text is pushed away, just as it was in the kernel,
+and you now have the last 50K of output, just like the kernel.
+It works, and nothing is lost.
+After each refresh you have an accurate snapshot of the output of your console.
+
+Output is passed from the kernel to acsint in the form of unicodes.
+This is a natural consequence of the PREWRITE notifier in vt.c.
+With this precedent established, I may as well pass the unicodes
+down to you, whence your adapter can support any language.
+Thus each character is actually 4 bytes wide.
+The buffers are not 50K, they are 200K,
+and your read buffer should be 200K plus a few hundred bytes for extra events.
+As mentioned earlier, the bridge layer handles all this for you,
+and makes the text available to you either as unicodes or as downshifted ascii.
+
+ACS_OBREAK
+
+Specify a gap of time, in tenths of a second,
+that is sufficient to indicate a new burst of output.
+See the MORECHARS event below for more details.
+
+read()
+
+The last system call supported by this device driver is read().
+Unlike the write call, each event is 4 byte aligned.
+An event will never be 2 or 3 bytes.
+Thus, when acsint is ready to pass unicodes down to user space,
+as described above, the reading offset is already 4 byte aligned.
+Here are the events.
+
+ACS_FGC
+
+This event indicates a new foreground console.
+The console number is the only parameter.
+Thus this is a 2 byte event.
+However, every event is 4 byte aligned,
+so you should skip past the next two bytes, and then process the next event.
+
+This command includes an automatic refresh.
+If you are switching to console 6, and that console has
+generated output that you have not seen,
+your buffers will be brought up to date.
+In other words, you don't have to issue the refresh command; it is done for you.
+Though there is no harm in issuing it again if you like.
+The new characters are passed down via the following event.
+
+ACS_TTY_NEWCHARS
+
+The next byte is the minor number of the current console.
+This is not needed, since ACS_FGC keeps you up to date.
+I guess it is here for historical reasons; you can ignore it.
+
+The next two bytes build an unsigned short,
+the number of new characters to be passed down.
+If this number is 1000, then the next 1000 unsigned ints,
+i.e. the next 4,000 bytes, hold the last thousand unicode values
+generated by the tty.
+
+ACS_KEYSTROKE
+
+The user has typed a key that acsint has intercepted.
+This is a 4 byte event.
+The parameters are the key code, the shift state, and the led state.
+
+Like FGC, this event includes an automatic refresh.
+However, the refresh, the new characters that you haven't seen,
+come before the keystroke,
+whereas they came after the FGC event.
+This makes sense if you think about it.
+You want to switch consoles, then update the buffer;
+whereas you want your buffer to be up to date before you process a key command.
+
+ACS_TTY_MORECHARS
+
+There are more characters that you haven't seen.
+An adapter typically responds to this by refreshing the buffer
+and then reading the new text.
+This is autoread mode, and most adapters run in autoread mode
+most of the time.
+
+This is an 8 byte event.
+The second byte indicates echo mode, and is 0 1 or 2.
+If 0, then the computer has generated output that is not an echo
+of your input.
+This event is thrown only once, until you refresh the buffer.
+Then it will be thrown again when new output is generated, and so on.
+
+If echo = 1 then this character, which is a unicode in the second int,
+is an echo of the user's keystroke.
+This brings the buffer up to date.
+It tells the adapter to speak that character, if it is
+configured to echo the user's keystrokes.
+
+If echo = 2 then this is an implied echo.
+It is not the same character as the entered keystroke, but is implied by
+that keystroke.  The most common example is spaces for tab, as in stty tab3.
+You may or may not want to speak these characters in echo mode.
+
+The first variant, with echo = 0, is not thrown
+if the new output occurs within a specified gap of time
+relative to the prior output.
+The driver considers this all the same output,
+as it has probably come from the same command.
+If you are examining words or letters in the output,
+or if you have paused to think about what you are reading, you don't want
+autoread to pull you down the page just because output continues to flow.
+This driver tries to determine whether a batch of output is new or not,
+and the easiest way to do this is by timing.
+Note however that any key passed to the console will be treated
+as a new command, and the next batch of output will be new output,
+and will throw the MORECHARS event.
+In other words, timing considerations fly out the window once you start typing.
+You can set this gap via ACS_OBREAK.
+The default is 5, or half a second.
+A gap of 0 turns the timing feature off entirely.
+
+ACS_REFRESH
+
+Finally, the REFRESH event is passed back to you
+when you issue the refresh command.
+It is the only action code that goes back and forth.
+You can treat it as a no-op.
+This is done so there is something to read, even if there are no new
+characters to pass down.
+The adapter can issue the refresh command, and then block read on the device,
+and something will be returned.
+At that point the adapter's buffer is brought up to date.
+
+That completes the description of the acsint device driver.
+As you can see, it is awkward to use,
+and one could easily lose data if events are not managed in the proper sequence.
+If you are interested in building a user space adapter, I would recommend
+working with the acsint bridge layer, which contains approximately 5,000
+lines of code that you really don't want to reinvent.
+
+Send any questions to the author
+using the email address at the top of this file.
--- a/drivers/accessibility/Kconfig	2014-12-01 21:48:42.573018749 -0500
+++ b/drivers/accessibility/Kconfig	2014-12-01 21:48:42.576019146 -0500
@@ -30,4 +30,33 @@ config A11Y_BRAILLE_CONSOLE
 
 	  If unsure, say N.
 
+config TTYCLICKS
+	tristate "tty clicks"
+	---help---
+	Generate clicks, using the pc speaker, as characters are sent
+	to the foreground console.  The sound is similar to an old style
+	teletype running at 2400 baud.
+	This provides audio feedback to a blind user,
+	even if speech or braille is not available.
+	It also throttles the output, so that screen after screen of text
+	does not fly by before the blind user has a chance to hit control s
+	and find out what is happening.
+	See Documentation/accessibility/ttyclicks.txt for more details.
+
+	  If unsure, say N.
+
+config ACSINT
+	tristate "acsint device driver"
+	---help---
+	The acsint device driver passes keyboard events and tty output
+	to a user space process, typically an adapter of some sort.
+	The adapter captures tty output and maintains it in a log
+	or circular buffer, one buffer for each virtual terminal.
+	Keystrokes can then be bound to reading commands to review this output.
+	This driver, and its associated adapters, provides access to linux
+	in multi-user mode. It serves no purpose in graphical mode.
+	See Documentation/accessibility/acsint.txt for more details.
+
+	  If unsure, say N.
+
 endif # ACCESSIBILITY
--- a/drivers/accessibility/Makefile	2014-12-01 21:48:42.580019676 -0500
+++ b/drivers/accessibility/Makefile	2014-12-01 21:48:42.583020074 -0500
@@ -1 +1,3 @@
 obj-y				+= braille/
+obj-$(CONFIG_TTYCLICKS) += ttyclicks.o
+obj-$(CONFIG_ACSINT) += acsint.o
--- a/drivers/accessibility/ttyclicks.c	2014-12-01 21:48:42.587020604 -0500
+++ b/drivers/accessibility/ttyclicks.c	2014-12-01 21:48:42.590021002 -0500
@@ -0,0 +1,706 @@
+/* ttyclicks.c: generate clicks as output is sent to the screen.
+ * If you are old enough, this will remind you of the sounds of a mechanical
+ * teletype running at 1200 baud.
+ * Why would you want such a thing?
+ * You might not, but a blind person might.
+ * The clicks provide valuable audio feedback to blind users.
+ * They know when the computer responds to a command,
+ * and they can discern the quantity and format of that response,
+ * before the speech synthesizer has uttered a word.
+ * It also throttles the output, which would otherwise fly by the screen
+ * faster than any blind person could even so much as hit control s.
+ * Please see Documentation/accessibility/ttyclicks.txt for more details.
+ *
+ * Copyright (C) Karl Dahlke, 2004-2013.
+ * This software may be freely distributed under the GPL,
+ * general public license, as articulated by the Free Software Foundation.
+ */
+
+#include <linux/notifier.h>
+#include <linux/keyboard.h>
+#include <linux/kd.h>
+#include <linux/vt.h>
+#include <linux/vt_kern.h>	/* for fg_console and speaker sounds */
+#include <linux/ctype.h>
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/io.h>		/* for inb() outb() */
+#include <linux/delay.h>
+
+#include "linux/ttyclicks.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Karl Dahlke - eklhad@gmail.com");
+MODULE_DESCRIPTION
+	("Console output generates clicks, resembling a mechanical teletype.");
+
+static int enabled = 1;
+module_param(enabled, int, 0);
+MODULE_PARM_DESC(enabled,
+		 "sounds are enabled as soon as this module is loaded, default = 1 (yes)");
+
+static int fgtty = 1;
+module_param(fgtty, int, 0);
+MODULE_PARM_DESC(fgtty,
+		 "foreground tty generates clicks and chirps, default = 1 (yes)");
+
+static int cursormotion;
+module_param(cursormotion, int, 0);
+MODULE_PARM_DESC(cursormotion,
+		 "generate clicks for output characters that move the cursor or set screen attributes; default is 0 (no)");
+
+static int kmsg = 1;
+module_param(kmsg, int, 0);
+MODULE_PARM_DESC(kmsg,
+		 "kernel warning/error message generates a sequence of tones to get your attension, default = 1 (yes)");
+
+static int sleep;
+module_param(sleep, int, 0);
+MODULE_PARM_DESC(sleep, "sleep between the clicks of the output characters - not yet implemented.");
+
+/* # define NO_KDS if your kernel does not yet support kd_mkpulse etc */
+
+/*
+ * Here are some symbols that we export to other modules
+ * so they can turn clicks on and off.
+ * They correspond (roughly) to the module parameters given above.
+ */
+
+bool ttyclicks_on = true;
+EXPORT_SYMBOL_GPL(ttyclicks_on);
+bool ttyclicks_tty = true;
+EXPORT_SYMBOL_GPL(ttyclicks_tty);
+bool ttyclicks_kmsg = true;
+EXPORT_SYMBOL_GPL(ttyclicks_kmsg);
+
+/*
+ * Don't click the ansi escape sequences that move the cursor on the screen.
+ * However, esc [ ... H moves the cursor to a new line, and might be worth
+ * a cr sound. Not sure about that one.
+ * escState holds the state of the escape sequence.
+ * 0 regular output, 1 escape received, 2 escape [ received.
+ * A letter ends the escape sequence and goes from state 1 or 2 back to state 0.
+ */
+
+static char escState;
+
+/*
+ * Kernel alert messages don't go through tty, and you won't hear any clicks.
+ * You don't want clicks anyways; you want something more.
+ * You want an unusual noise that alerts you -
+ * there is a kernel message that requires your attention!
+ * When a newline comes through printk,
+ * I make a sound with up and down tones.
+ */
+
+static const short printk_sound[] = {
+	730, 7, 760, 7, 790, 7, 760, 7, 730, 7, -1, 7, 0, 0
+};
+
+static void my_printk(struct console *cons, const char *msg, unsigned int len)
+{
+	char c;
+	while (len--) {
+		c = *msg++;
+		if (c == '\n' && ttyclicks_on & ttyclicks_kmsg)
+			ttyclicks_notes(printk_sound);
+	}
+}				/* my_printk */
+
+static struct console clickconsole = {
+	.name = "tty clicks",
+	.write = my_printk,
+	.flags = CON_ENABLED,
+};
+
+/*
+ * Now for something subtle.
+ * I often hit caps lock by accident.  Don't we all?
+ * But I can't tell the difference, until I've typed an entire paragraph
+ * in upper case.
+ * So it is helpful to hear a high beep every time a capital letter is echoed.
+ * It's easy to test for upper case (at least in English).
+ * but when does an output character represent an echo of an input character?
+ * Don't count on tty cooked mode to tell you;
+ * lots of editors put the tty in raw mode,
+ * and then there's ssh (when you're working remotely), and so on.
+ * No - we need a more general approach.
+ * I watch the keystrokes as they come in, and give them time stamps.
+ * If an output letter matches an input letter, and not too much time
+ * has gone by, I call it an echo character.
+ * It's not perfect, but nearly so.
+ * That is the only reason to monitor keystrokes.
+ * If I didn't want echo capital letters to sound different,
+ * I wouldn't need a keyboard notifier at all.
+ * Retain up to 16 keystrokes with time stamps in jiffies
+ * in a circular buffer with head and tail pointers.
+ * kb notifier puts keys on at the head,
+ * and vt notifier takes keys off at the tail,
+ * matching them against vt output and checking for echo.
+ */
+
+#define ECHOEXPIRE 3		/* in seconds */
+#define ECHOMAX 16
+
+static struct {
+	char inkey;
+	unsigned long intime;
+} echochars[ECHOMAX];
+static int echead, ectail;
+
+/* char is displayed on screen; is it echo? */
+static int charIsEcho(char c)
+{
+	int j = ectail;
+	char d;
+
+	while (j != echead) {
+		if ((long)jiffies - (long)echochars[j].intime > HZ * ECHOEXPIRE) {
+/* this keystroke too old, discard it */
+			if (++j == ECHOMAX)
+				j = 0;
+			ectail = j;
+			continue;
+		}
+/* This one has to match, or other output is getting in the way. */
+		d = echochars[j].inkey;
+		if (++j == ECHOMAX)
+			j = 0;
+		if (d == c) {
+			ectail = j;
+			return 1;
+		}
+	}
+
+	ectail = echead;
+	return 0;
+}				/* charIsEcho */
+
+static int
+keystroke(struct notifier_block *this_nb, unsigned long type, void *data)
+{
+	struct keyboard_notifier_param *param = data;
+	char key = param->value;
+	int downflag = param->down;
+	int shiftstate = param->shift;
+	int j;
+
+	/* if no sounds, then no need to do anything. */
+	/* Also, no raw, no control keys, and only down events. */
+	if (!(ttyclicks_on & ttyclicks_tty) ||
+	type != KBD_KEYSYM ||
+	param->vc->vc_mode == KD_GRAPHICS ||
+	downflag == 0 ||
+	key == 0 ||
+	shiftstate & 0xe)
+		return NOTIFY_DONE;
+
+	j = echead;
+	if (++j == ECHOMAX)
+		j = 0;
+/* typing ahead, is there room for this key in the echo buffer? */
+	if (j != ectail) {
+		echochars[echead].inkey = key;
+		echochars[echead].intime = jiffies;
+		echead = j;
+	}
+
+	return NOTIFY_DONE;
+}				/* keystroke */
+
+/*
+ * Here's the deal about notifier priority.
+ * All this module does is make clicks as characters appear on screen.
+ * Any other module is probably going to be more important.
+ * In fact other modules may want to eat events before this one
+ * makes its noises. So give this module a low priority.
+ * 0 is default, so select a negative number.
+ */
+
+static struct notifier_block nb_key = {
+	.notifier_call = keystroke,
+	.priority = -70
+};
+
+/* Here are some routines to click the speaker, or make tones, etc. */
+/* In each case ttyclicks_on is the master switch. */
+
+/* intervals measured in microseconds */
+#define TICKS_CLICK 600
+#define TICKS_CHARWAIT 4000
+
+#ifdef NO_KDS
+
+/* This stuff belongs in drivers/input/misc/pcspkr.c */
+
+/* Use the global PIT lock ! */
+#include <linux/i8253.h>
+
+/* Toggle the speaker, but not if a tone is sounding */
+static void speaker_toggle(void)
+{
+	char c;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&i8253_lock, flags);
+	c = inb_p(0x61);
+	if ((c & 3) != 3) {
+		c &= 0xfe;
+		c ^= 2;		/* toggle */
+		outb(c, 0x61);
+	}
+	raw_spin_unlock_irqrestore(&i8253_lock, flags);
+}
+
+static void speaker_sing(unsigned int freq)
+{
+	unsigned long flags;
+	raw_spin_lock_irqsave(&i8253_lock, flags);
+	if (freq) {
+		unsigned int count = PIT_TICK_RATE / freq;
+		/* set command for counter 2, 2 byte write */
+		outb_p(0xB6, 0x43);
+		/* select desired HZ */
+		outb_p(count & 0xff, 0x42);
+		outb((count >> 8) & 0xff, 0x42);
+		/* enable counter 2 */
+		outb_p(inb_p(0x61) | 3, 0x61);
+	} else {
+		/* disable counter 2 */
+		outb(inb_p(0x61) & 0xFC, 0x61);
+	}
+	raw_spin_unlock_irqrestore(&i8253_lock, flags);
+}
+
+static void my_mksteps(int f1, int f2, int step, int duration);
+
+#endif
+
+/* the sound of a character click */
+void ttyclicks_click(void)
+{
+	if (!ttyclicks_on)
+		return;
+#ifndef NO_KDS
+	kd_mkpulse(TICKS_CLICK);
+#else
+	speaker_toggle();
+	udelay(TICKS_CLICK);
+	speaker_toggle();
+#endif
+}				/* ttyclicks_click */
+EXPORT_SYMBOL_GPL(ttyclicks_click);
+
+void ttyclicks_cr(void)
+{
+	if (!ttyclicks_on)
+		return;
+#ifndef NO_KDS
+	kd_mksteps(2900, 3600, 10, 10);
+#else
+	my_mksteps(2900, 3600, 10, 10);
+#endif
+}				/* ttyclicks_cr */
+EXPORT_SYMBOL_GPL(ttyclicks_cr);
+
+#ifdef NO_KDS
+
+/* This stuff belongs in drivers/tty/vt/keyboard.c */
+
+/*
+ * Push notes onto a sound fifo and play them via an asynchronous thread.
+ * kd_mksound is a single tone, but kd_mknotes is a series of notes.
+ * this is used primarily by the accessibility modules, to sound
+ * various alerts and conditions for blind users.
+ * This is particularly helpful when the adapter is not working,
+ * for whatever reason.  These functions are central to the kernel,
+ * and do not depend on sound cards, loadable modules, etc.
+ * These notes can also alert a system administrator to conditions
+ * that warrant immediate attention.
+ * Each note is specified by 2 shorts.  The first is the frequency in hurtz,
+ * and the second is the duration in hundredths of a second.
+ * A frequency of -1 is a rest.
+ * A frequency of 0 ends the list of notes.
+ */
+
+#define SF_LEN 64		/* length of sound fifo */
+static short sf_fifo[SF_LEN];
+static int sf_head, sf_tail;
+static DEFINE_RAW_SPINLOCK(soundfifo_lock);
+
+/* Pop the next sound out of the sound fifo. */
+static void pop_soundfifo(unsigned long);
+
+static DEFINE_TIMER(kd_mknotes_timer, pop_soundfifo, 0, 0);
+
+static void pop_soundfifo(unsigned long notUsed)
+{
+	unsigned long flags;
+	int freq, duration;
+	int i;
+	long jifpause;
+
+	raw_spin_lock_irqsave(&soundfifo_lock, flags);
+
+	i = sf_tail;
+	if (i == sf_head) {
+		freq = 0;
+		duration = 0;
+	} else {
+		freq = sf_fifo[i];
+		duration = sf_fifo[i + 1];
+		i += 2;
+		if (i == SF_LEN)
+			i = 0;
+		sf_tail = i;
+	}
+
+	raw_spin_unlock_irqrestore(&soundfifo_lock, flags);
+
+	if (freq == 0) {
+		/* turn off singing speaker */
+		speaker_sing(0);
+		del_timer(&kd_mknotes_timer);
+		return;
+	}
+
+	jifpause = msecs_to_jiffies(duration);
+	/* not sure of the rounding, if duration < HZ */
+	if (jifpause == 0)
+		jifpause = 1;
+	mod_timer(&kd_mknotes_timer, jiffies + jifpause);
+
+	if (freq < 0) {
+		/* This is a rest between notes */
+		speaker_sing(0);
+	} else {
+		speaker_sing(freq);
+	}
+}
+
+/* Push a string of notes into the sound fifo. */
+static void my_mknotes(const short *p)
+{
+	int i;
+	bool wake = false;
+	unsigned long flags;
+
+	if (*p == 0)
+		return;		/* empty list */
+
+	raw_spin_lock_irqsave(&soundfifo_lock, flags);
+
+	i = sf_head;
+	if (i == sf_tail)
+		wake = true;
+
+	/* Copy shorts into the fifo, until the terminating zero. */
+	while (*p) {
+		sf_fifo[i++] = *p++;
+		sf_fifo[i++] = (*p++) * 10;
+		if (i == SF_LEN)
+			i = 0;	/* wrap around */
+		if (i == sf_tail) {
+			/* fifo is full */
+			goto done;
+		}
+		sf_head = i;
+	}
+
+	/* try to add on a rest, to carry the last note through */
+	sf_fifo[i++] = -1;
+	sf_fifo[i++] = 10;
+	if (i == SF_LEN)
+		i = 0;		/* wrap around */
+	if (i != sf_tail)
+		sf_head = i;
+
+done:
+	raw_spin_unlock_irqrestore(&soundfifo_lock, flags);
+
+	/* first sound,  get things started. */
+	if (wake)
+		pop_soundfifo(0);
+}
+
+/* Push an ascending or descending sequence of notes into the sound fifo.
+ * Step is a geometric factor on frequency, increase by x percent.
+ * 100% goes up by octaves, -50% goes down by octaves.
+ * 12% is a wholetone scale, while 6% is a chromatic scale.
+ * Duration is in milliseconds, for very fast frequency sweeps.  But this
+ * is based on jiffies timing, so is subject to the resolution of HZ. */
+static void my_mksteps(int f1, int f2, int step, int duration)
+{
+	int i;
+	bool wake = false;
+	unsigned long flags;
+
+	/* are the parameters in range? */
+	if (step != (char)step)
+		return;
+	if (duration <= 0 || duration > 2000)
+		return;
+	if (f1 < 50 || f1 > 8000)
+		return;
+	if (f2 < 50 || f2 > 8000)
+		return;
+
+	/* avoid infinite loops */
+	if (step == 0 || (f1 < f2 && step < 0) || (f1 > f2 && step > 0))
+		return;
+
+	raw_spin_lock_irqsave(&soundfifo_lock, flags);
+
+	i = sf_head;
+	if (i == sf_tail)
+		wake = true;
+
+	/* Copy shorts into the fifo, until start reaches end */
+	while ((step > 0 && f1 < f2) || (step < 0 && f1 > f2)) {
+		sf_fifo[i++] = f1;
+		sf_fifo[i++] = duration;
+		if (i == SF_LEN)
+			i = 0;	/* wrap around */
+		if (i == sf_tail) {
+			/* fifo is full */
+			goto done;
+		}
+		sf_head = i;
+		f1 = f1 * (100 + step) / 100;
+		if (f1 < 50 || f1 > 8000)
+			break;
+	}
+
+	/* try to add on a rest, to carry the last note through */
+	sf_fifo[i++] = -1;
+	sf_fifo[i++] = 10;
+	if (i == SF_LEN)
+		i = 0;		/* wrap around */
+	if (i != sf_tail)
+		sf_head = i;
+
+done:
+	raw_spin_unlock_irqrestore(&soundfifo_lock, flags);
+
+	/* first sound,  get things started. */
+	if (wake)
+		pop_soundfifo(0);
+}
+
+#endif
+
+/* Put a string of notes into the sound fifo. */
+void ttyclicks_notes(const short *p)
+{
+	if (!ttyclicks_on)
+		return;
+#ifdef NO_KDS
+	my_mknotes(p);
+#else
+	kd_mknotes(p);
+#endif
+}				/* ttyclicks_notes */
+EXPORT_SYMBOL_GPL(ttyclicks_notes);
+
+void ttyclicks_steps(int f1, int f2, int step, int duration)
+{
+	if (!ttyclicks_on)
+		return;
+#ifdef NO_KDS
+	my_mksteps(f1, f2, step, duration);
+#else
+	kd_mksteps(f1, f2, step, duration);
+#endif
+}				/* ttyclicks_steps */
+EXPORT_SYMBOL_GPL(ttyclicks_steps);
+
+void ttyclicks_bell(void)
+{
+	static const short notes[] = {
+		1800, 10, 0, 0
+	};
+	ttyclicks_notes(notes);
+}				/* ttyclicks_bell */
+EXPORT_SYMBOL_GPL(ttyclicks_bell);
+
+/* Returns a time in microseconds to wait. */
+static int soundFromChar(char c, int minor)
+{
+	static const short capnotes[] = {
+		3000, 3, 0, 0
+	};
+
+/* are sounds disabled? */
+	if (!ttyclicks_on)
+		return 0;
+
+	if (c == '\07') {
+		ttyclicks_bell();
+		return 0;
+	}
+
+	if (!ttyclicks_tty)
+		return 0;
+
+/* Don't click for background screens */
+	if (minor != fg_console + 1)
+		return 0;
+
+	if (c == '\n') {
+		ttyclicks_cr();
+		return 0;
+	}
+
+	if (charIsEcho(c) && c >= 'A' && c <= 'Z') {
+		ttyclicks_notes(capnotes);
+		return TICKS_CHARWAIT;
+	}
+
+/* Treat a nonprintable characterlike a space; just pause. */
+	if (c >= 0 && c <= ' ')
+		return TICKS_CHARWAIT;
+
+/* regular printable character */
+	ttyclicks_click();
+	return TICKS_CHARWAIT - TICKS_CLICK;
+}				/* soundFromChar */
+
+/* Get char from the console, and make the sound. */
+static int
+vt_out(struct notifier_block *this_nb, unsigned long type, void *data)
+{
+	struct vt_notifier_param *param = data;
+	struct vc_data *vc = param->vc;
+	int minor = vc->vc_num + 1;
+	int msecs = 0, usecs = 0;
+	long jifpause;
+	int unicode = param->c;
+	char c = param->c;
+
+	if (type != VT_PREWRITE)
+		goto done;
+
+	if (param->vc->vc_mode == KD_GRAPHICS)
+		goto done;
+	if (unicode >= 128) {
+		escState = 0;
+		goto done;
+	}
+
+	if (escState == 2) {
+		if (isalpha(c)) {
+			/* a letter indicates end of escape sequence. */
+			escState = 0;
+			if(c == 'H')
+				ttyclicks_cr();
+		}
+		goto done;
+	}
+
+	if (escState == 1) {
+		if (c == '[') {
+			escState = 2;
+			goto done;
+		}
+/* Anything else closes the sequence, that's wrong, but will do for now. */
+		if(c != '\33')
+			escState = 0;
+		goto done;
+	} else if (c == '\33' && !cursormotion) {
+		escState = 1;
+		goto done;
+	}
+
+	if (!isdigit(c) && c != '?' && c != '#' && c != ';')
+		escState = 0;
+
+	usecs = soundFromChar(c, minor);
+
+/*
+ * If it's the bell, I make the beep, not the console.
+ * This is the only char that this module eats.
+ */
+
+	if (c == 7)
+		return NOTIFY_STOP;
+
+	if (!usecs)
+		goto done;
+
+/* Tell the process to sleep. */
+	msecs = (usecs + 800) / 1000;
+	jifpause = msecs_to_jiffies(msecs);
+/* jifpause should always be positive */
+	if (sleep && jifpause > 0) {
+
+		/*
+		 * This magical line of code only works if you edit vt.c
+		 * and recompile the kernel.
+		 * A patch for 3.12.3 can be found in the patch directory.
+		 */
+
+		param->c = 0xac97;
+
+	} else {
+
+/*
+ * no sleep, spin in a cpu cycle.
+ * It's easy, and works,
+ * but will suspend the music you are playing in the background.
+ * You won't here the rest of Hey Jude until output has ceased.
+ */
+
+		udelay(usecs);
+	}
+
+done:
+	return NOTIFY_DONE;
+}				/* vt_out */
+
+static struct notifier_block nb_vt = {
+	.notifier_call = vt_out,
+	.priority = -70
+};
+
+/* Load and unload the module. */
+
+static int __init click_init(void)
+{
+	int rc;
+
+	ttyclicks_on = enabled;
+	ttyclicks_tty = fgtty;
+	ttyclicks_kmsg = kmsg;
+
+	rc = register_vt_notifier(&nb_vt);
+	if (rc)
+		return rc;
+
+	rc = register_keyboard_notifier(&nb_key);
+	if (rc) {
+		unregister_vt_notifier(&nb_vt);
+		return rc;
+	}
+
+	register_console(&clickconsole);
+
+	return rc;
+}				/* click_init */
+
+static void __exit click_exit(void)
+{
+	ttyclicks_on = 0;
+
+	unregister_console(&clickconsole);
+	unregister_keyboard_notifier(&nb_key);
+	unregister_vt_notifier(&nb_vt);
+
+#ifdef NO_KDS
+/* possible race conditions here with timers hanging around */
+	sf_head = sf_tail = 0;
+	pop_soundfifo(0);
+#endif
+}				/* click_exit */
+
+module_init(click_init);
+module_exit(click_exit);
--- a/drivers/accessibility/acsint.c	2014-12-01 21:48:42.595021664 -0500
+++ b/drivers/accessibility/acsint.c	2014-12-01 21:48:42.598022062 -0500
@@ -0,0 +1,1239 @@
+/* Acsint - Accessibility intercepter.
+ * Originally written by Saqib Shaikh in 2005.
+ * Modified by Karl Dahlke in 2011 to use notifiers.
+ */
+
+#include <linux/kernel.h>
+#include <linux/notifier.h>
+#include <linux/kbd_kern.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>		/* malloc and free */
+#include <linux/vt.h>
+#include <linux/vt_kern.h>	/* for fg_console */
+#include <linux/console.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/tty_flip.h>
+#include <linux/miscdevice.h>
+#include <linux/version.h>
+#include <linux/poll.h>
+
+#include "linux/ttyclicks.h"
+#include "linux/acsint.h"
+
+#define ACS_DEVICE "/dev/acsint"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Karl Dahlke - eklhad@gmail.com");
+MODULE_DESCRIPTION
+    ("Accessibility intercepter - pass keystroke and tty events to user space");
+
+static int major;
+module_param(major, int, 0);
+MODULE_PARM_DESC(major,
+		 "major number for /dev/acsint, default is dynamic allocation through misc_register");
+
+/* For various critical sections of code. */
+static DEFINE_RAW_SPINLOCK(acslock);
+
+/* circular buffer of output characters received from the tty */
+struct cbuf {
+	unsigned int area[65536];
+	unsigned int *start, *end;
+	unsigned int *head, *tail;
+/* mark the place where we last copied data to user space */
+	unsigned int *mark;
+/* Mark the point where we last saw an echo character */
+	unsigned int *echopoint;
+};
+
+/* These are allocated, one per console, as needed. */
+static struct cbuf *cbuf_tty[MAX_NR_CONSOLES];
+
+/* in case we can't malloc a buffer */
+static const char cb_nomem_message[] =
+    "Kernel cannot allocate space for this console";
+
+/* set to 1 if you have sent the above nomem message down to the user */
+static unsigned char cb_nomem_refresh[MAX_NR_CONSOLES];
+
+/* set to 1 if you have tried to allocate */
+static unsigned char cb_nomem_alloc[MAX_NR_CONSOLES];
+
+/* Staging area to copy tty data down to user space */
+/* This is a snapshot of the circular buffer. */
+static unsigned int cb_staging[65536];
+
+/* size of userland buffer; characters will copy from staging to this buffer */
+static int user_bufsize = 256;
+
+/* jiffies value for the last output character. */
+/* This is reset if the last output character is echo. */
+static unsigned long last_oj;
+/* How many tenths of a second separate one burst of output from the next? */
+static int outputbreak = 5;
+
+/* Initialize / reset the variables in the circular buffer. */
+static void cb_reset(struct cbuf *cb)
+{
+	if (!cb)
+		return;		/* never allocated */
+	cb->start = cb->area;
+	cb->end = cb->area + 65536;
+	cb->head = cb->start;
+	cb->tail = cb->start;
+	cb->mark = cb->start;
+	cb->echopoint = 0;
+}
+
+/* check to see if the circular buffer was allocated. */
+/* If never attempted, try to allocate it. */
+/* mino is minor-1, a 0 based index into arrays, similar to fg_console. */
+static void checkAlloc(int mino, bool from_vt)
+{
+	struct cbuf *cb = cbuf_tty[mino];
+	if (cb)
+		return;		/* already allocated */
+	if (cb_nomem_alloc[mino])
+		return;		/* already tried to allocate */
+	cb_nomem_alloc[mino] = 1;
+	cb = kmalloc(sizeof(*cb), (from_vt ? GFP_ATOMIC : GFP_KERNEL));
+	if (!cb) {
+		printk(KERN_ERR "Failed to allocate memory for console %d.\n",
+		       mino + 1);
+		return;
+	}
+	cb_reset(cb);
+	cbuf_tty[mino] = cb;
+}
+
+/* Put a character on the end of the circular buffer.
+ * Drop the oldest character if the buffer is full.
+ * This is called under a spinlock, so we don't have to worry about the reader
+ * draining characters while this routine adds characters on. */
+static void cb_append(struct cbuf *cb, unsigned int c)
+{
+	if (!cb)
+		return;		/* should never happen */
+	*cb->head = c;
+	++cb->head;
+	if (cb->head == cb->end)
+		cb->head = cb->start;
+	if (cb->head == cb->tail) {
+		/* buffer full, drop the last character */
+		if (cb->tail == cb->mark)
+			cb->mark = 0;
+		if (cb->tail == cb->echopoint)
+			cb->echopoint = 0;
+		++cb->tail;
+		if (cb->tail == cb->end)
+			cb->tail = cb->start;
+	}
+}
+
+/* Indicate which keys, by key code, are meta.  For example,
+ * shift, alt, numlock, etc.  These are the state changing keys.
+ * Also flag the simulated shift states, on or off, for shift,
+ * ralt, control, lalt.
+ * I don't do the bookkeeping for the standar keys, the kernel does that.
+ * I keep track for any other keys you might equate with shift or alt etc. */
+
+#define ACS_SS_KERNEL 0x20 /* states handled by the kernel */
+
+static unsigned char ismeta[ACS_NUM_KEYS];
+static unsigned char metaflag[4];
+
+static void
+reset_meta(void)
+{
+	int j;
+
+	for (j = 0; j < ACS_NUM_KEYS; ++j)
+		ismeta[j] = 0;
+/* These all have to be less than ACS_NUM_KEYS */
+	ismeta[KEY_LEFTCTRL] = ACS_SS_KERNEL;
+	ismeta[KEY_RIGHTCTRL] = ACS_SS_KERNEL;
+	ismeta[KEY_LEFTSHIFT] = ACS_SS_KERNEL;
+	ismeta[KEY_RIGHTSHIFT] = ACS_SS_KERNEL;
+	ismeta[KEY_LEFTALT] = ACS_SS_KERNEL;
+	ismeta[KEY_RIGHTALT] = ACS_SS_KERNEL;
+	ismeta[KEY_CAPSLOCK] = ACS_SS_KERNEL;
+	ismeta[KEY_NUMLOCK] = ACS_SS_KERNEL;
+	ismeta[KEY_SCROLLLOCK] = ACS_SS_KERNEL;
+
+	for(j=0; j<4; ++j)
+		metaflag[j] = 0;
+} /* reset_meta */
+
+
+/* Indicate which keys should be captured by your running adapter.
+ * This is an unsigned short, with a bit for each shift alt control combination.
+ * This includes the first bit, which corresponds to a shift state of 0,
+ * or the plain key.  You want that for function keys etc,
+ * but probably not for letters on the main keyboard.
+ * Those should always pass through to the console.
+ * But I don't place any restrictions on what is intercepted,
+ * so do whatever you like. */
+
+static unsigned short capture[ACS_NUM_KEYS];
+
+/* If a key is captured, it can still be passed through to the console. */
+
+static unsigned short passt[ACS_NUM_KEYS];
+
+static void clear_keys(void)
+{
+	int i;
+	for (i = 0; i < ACS_NUM_KEYS; i++)
+		capture[i] = passt[i] = 0;
+}
+
+/* divert all keys to user space, to grab the next key or build a string. */
+static bool key_divert;
+
+/* Monitor keystrokes that are passed to the console, by sending
+ * them to user space as well. This is like /usr/bin/tee. */
+static bool key_monitor;
+
+/* pass the next key through to the console. */
+static bool key_bypass;
+
+/* The array "rbuf" is used for passing key/tty events to user space.
+ * A reading buffer of sorts.  See device_read() below.
+ * Despite the names head and tail, it's not a true circular buffer.
+ * The process has to read the data before rbuf_head reaches rbuf_end,
+ * or data is lost.
+ * That's not a problem, because you just can't type faster
+ * than the daemon can gather up those keystrokes.
+ * Every event is 4 bytes, except echo, which is 8.
+ * Thus everything stays 4 byte aligned.
+ * This is necessary to pass down unicodes.
+ */
+
+#define RBUF_LEN 400
+static char rbuf[RBUF_LEN];
+static const char *rbuf_end = rbuf + RBUF_LEN;
+static char *rbuf_tail, *rbuf_head;
+
+/* Wait until this driver has some data to read. */
+DECLARE_WAIT_QUEUE_HEAD(wq);
+
+static bool in_use;		/* only one process opens this device at a time */
+static int last_fgc;		/* last fg_console */
+
+/* Push characters onto the input queue of the foreground tty.
+ * This is for macros, or cut&paste. */
+static void tty_pushstring(const char *cp, int len)
+{
+	struct vc_data *d = vc_cons[fg_console].d;
+
+	if (!d)
+		return;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 11)
+	tty_insert_flip_string(d->port.tty, cp, len);
+	tty_flip_buffer_push(d->port.tty);
+#else
+	tty_insert_flip_string(&d->port, cp, len);
+	tty_flip_buffer_push(&d->port);
+#endif
+}				/* tty_pushstring */
+
+/* File operations for /dev/acsint. */
+
+static int device_open(struct inode *inode, struct file *file)
+{
+	int j;
+
+/* A theoretical race condition here; too unlikely for me to worry about. */
+	if (in_use)
+		return -EBUSY;
+
+	for (j = 0; j < MAX_NR_CONSOLES; ++j) {
+		cb_reset(cbuf_tty[j]);
+		cb_nomem_refresh[j] = 0;
+		cb_nomem_alloc[j] = 0;
+	}
+
+	reset_meta();
+	clear_keys();
+	key_divert = false;
+	key_monitor = false;
+	key_bypass = false;
+
+/* At startup we tell the process which virtual console it is on.
+ * Place this directive in rbuf to be read. */
+	rbuf[0] = ACS_FGC;
+	rbuf[1] = fg_console + 1;	/* minor number */
+	rbuf_tail = rbuf;
+	rbuf_head = rbuf + 4;
+	last_fgc = fg_console;
+	checkAlloc(fg_console, false);
+
+	in_use = true;
+	return 0;
+}
+
+static int device_close(struct inode *inode, struct file *file)
+{
+	in_use = false;
+	rbuf_head = rbuf_tail = rbuf;
+	return 0;
+}
+
+static ssize_t device_read(struct file *file, char *buf, size_t len,
+			   loff_t * offset)
+{
+	int bytes_read = 0;
+	struct cbuf *cb;
+	bool catchup;
+	bool catchup_head, catchup_echo;
+/* catch up length - how many characters to copy down to user space */
+	int culen = 0;
+	unsigned int *cup = 0;	/* the catchup poin */
+	char *temp_head, *temp_tail, *t;
+	int j, j2;
+	int retval;
+	unsigned long irqflags;
+
+	if (!in_use)
+		return 0;	/* should never happen */
+
+	retval = wait_event_interruptible(wq, (rbuf_head > rbuf_tail));
+	if (retval)
+		return retval;
+
+/* you can only read on behalf of the foreground console */
+	cb = cbuf_tty[fg_console];
+
+/* Use temp pointers, more keystrokes could be appended while
+ * we're doing this; that's ok. */
+	temp_head = rbuf_head;
+	temp_tail = rbuf_tail;
+
+/* Skip ahead to the last FGC event if present. */
+	for (t = temp_tail; t < temp_head; t += 4) {
+		if (*t == ACS_FGC)
+			temp_tail = t;
+		if (*t == ACS_TTY_MORECHARS)
+			t += 4;
+	}
+
+	raw_spin_lock_irqsave(&acslock, irqflags);
+
+	catchup = false;
+	catchup_head = false;
+	catchup_echo = false;
+
+	if ((!cb && !cb_nomem_refresh[fg_console]) ||
+	    (cb && cb->head != cb->mark)) {
+		/* MORECHARS echo 0 doesn't force us to catch up,
+		 * but anything else does.
+		 * echo forces a catch up to the echopoint.
+		 * Other commands force catch up to the head. */
+		for (t = temp_tail; t < temp_head; t += 4) {
+			if (*t == ACS_TTY_MORECHARS) {
+				t += 4;
+				if (t[-3])
+					catchup_echo = true;
+				continue;
+			}
+			catchup_head = true;
+			break;
+		}
+	}
+
+	if (catchup_echo && cb->echopoint)
+		catchup = true, cup = cb->echopoint;
+
+	if (catchup_head)
+		catchup = true, cup = cb->head;
+
+	if (catchup) {
+		if (cb) {
+			if (cb->mark == 0)
+				cb->mark = cb->tail;
+			if (cup >= cb->mark)
+				culen = cup - cb->mark;
+			else
+				culen =
+				    (cb->end - cb->mark) + (cup - cb->start);
+		} else {
+			culen = sizeof(cb_nomem_message) - 1;
+		}
+
+		if (cb) {
+			/* One chunk or two. */
+			if (cup >= cb->mark) {
+				if (culen)
+					memcpy(cb_staging, cb->mark, culen * 4);
+			} else {
+				j = cb->end - cb->mark;
+				memcpy(cb_staging, cb->mark, j * 4);
+				j2 = cup - cb->start;
+				if (j2)
+					memcpy(cb_staging + j, cb->start,
+					       j2 * 4);
+			}
+			cb->mark = cup;
+			cb->echopoint = 0;
+		} else {
+			for (j = 0; j < culen; ++j)
+				cb_staging[j] = cb_nomem_message[j];
+			cb_nomem_refresh[fg_console] = 1;
+		}
+	}
+
+	raw_spin_unlock_irqrestore(&acslock, irqflags);
+
+/* Now pass down the events. */
+/* First fgc, then catch up, then the rest. */
+	if (*temp_tail == ACS_FGC && len >= 4) {
+		if (copy_to_user(buf, temp_tail, 4))
+			return -EFAULT;
+		temp_tail += 4;
+		bytes_read += 4;
+		buf += 4;
+		len -= 4;
+	}
+
+	if (catchup) {
+		cup = cb_staging;
+/* ratchet culen down to the size of the userland buffer */
+		if (culen > user_bufsize) {
+			j = culen - user_bufsize;
+			cup += j, culen -= j;
+		}
+	}
+
+	if (catchup && len >= (culen + 1) * 4) {
+		char cu_cmd[4];	/* the catch up command */
+		cu_cmd[0] = ACS_TTY_NEWCHARS;
+/* Put in the minor number here, though I don't think we need it. */
+		cu_cmd[1] = fg_console + 1;
+		cu_cmd[2] = culen;
+		cu_cmd[3] = (culen >> 8);
+		if (copy_to_user(buf, cu_cmd, 4))
+			return -EFAULT;
+
+		if (culen && copy_to_user(buf + 4, cup, culen * 4))
+			return -EFAULT;
+		bytes_read += (culen + 1) * 4;
+		buf += (culen + 1) * 4;
+		len -= (culen + 1) * 4;
+	}
+
+/* And the rest of the events. */
+	j = temp_head - temp_tail;
+	if (j > len)
+		j = len;	/* should never happen */
+	if (j) {
+		if (copy_to_user(buf, temp_tail, j))
+			return -EFAULT;
+		temp_tail += j;
+		buf += j;
+		bytes_read += j;
+		len -= j;
+	}
+
+/* Pull the pointers back to start. */
+/* This should happen almost every time. */
+	raw_spin_lock_irqsave(&acslock, irqflags);
+	rbuf_tail = temp_tail;
+	if (rbuf_head == rbuf_tail)
+		rbuf_head = rbuf_tail = rbuf;
+	raw_spin_unlock_irqrestore(&acslock, irqflags);
+
+	*offset += bytes_read;
+	return bytes_read;
+}				/* device_read */
+
+static ssize_t device_write(struct file *file, const char *buf, size_t len,
+			    loff_t * offset)
+{
+	char c;
+	const char *p = buf;
+	int j, key, shiftstate, teebit, bytes_write;
+	int nn;			/* number of notes */
+	short notes[2 * (10 + 1)];
+	int isize;		/* size of input to inject */
+	int f1, f2, step, duration;	/* for kd_mksteps */
+	unsigned long irqflags;
+
+	if (!in_use)
+		return 0;	/* should never happen */
+
+	while (len) {
+		get_user(c, p++);
+		len--;
+
+		switch (c) {
+		case ACS_CLEAR_KEYS:
+			clear_keys();
+			reset_meta();
+			break;
+
+		case ACS_SET_KEY:
+			if (len < 2)
+				break;
+			get_user(key, p++);
+			key = (unsigned char)key;
+			len--;
+			get_user(shiftstate, p++);
+			len--;
+			if (key < ACS_NUM_KEYS) {
+				teebit = (shiftstate & ACS_KEY_T);
+				shiftstate &= 0xf;
+				capture[key] |=
+				    (1 << shiftstate);
+				if(teebit)
+					passt[key] |=
+					    (1 << shiftstate);
+				else
+					passt[key] &=
+					    ~(1 << shiftstate);
+			}
+			break;
+
+		case ACS_UNSET_KEY:
+			if (len < 2)
+				break;
+			get_user(key, p++);
+			key = (unsigned char)key;
+			len--;
+			get_user(shiftstate, p++);
+			len--;
+			if (key < ACS_NUM_KEYS) {
+				passt[key] = 0;
+				shiftstate &= 0xf;
+				capture[key] &=
+				    ~((unsigned short)1 << shiftstate);
+			}
+			break;
+
+		case ACS_ISMETA:
+			if (len < 2)
+				break;
+			get_user(key, p++);
+			key = (unsigned char)key;
+			len--;
+			get_user(c, p++);
+			len--;
+			if (key < ACS_NUM_KEYS)
+				ismeta[key] = (unsigned char)c;
+			break;
+
+		case ACS_CLICK:
+			ttyclicks_click();
+			break;
+
+		case ACS_CR:
+			ttyclicks_cr();
+			break;
+
+		case ACS_SOUNDS:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			ttyclicks_on = c;
+			break;
+
+		case ACS_SOUNDS_TTY:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			ttyclicks_tty = c;
+			break;
+
+		case ACS_SOUNDS_KMSG:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			ttyclicks_kmsg = c;
+			break;
+
+		case ACS_NOTES:
+			if (len < 1)
+				break;
+			get_user(nn, p++);
+			len--;
+			for (j = 0; j < nn && j < 10 && len >= 3; ++j, len -= 3) {
+				get_user(c, p++);
+				notes[2 * j] = (unsigned char)c;
+				get_user(c, p++);
+				notes[2 * j] |= ((short)c << 8);
+				get_user(c, p++);
+				notes[2 * j + 1] = (unsigned char)c;
+			}
+			notes[2 * j] = 0;
+			if (j)
+				ttyclicks_notes(notes);
+			for (; j < nn && len >= 3; ++j, len -= 3)
+				p += 3;
+			break;
+
+		case ACS_BYPASS:
+			key_bypass = true;
+			break;
+
+		case ACS_DIVERT:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			key_divert = (c != 0);
+			break;
+
+		case ACS_MONITOR:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			key_monitor = (c != 0);
+			break;
+
+		case ACS_OBREAK:
+			if (len < 1)
+				break;
+			get_user(c, p++);
+			len--;
+			outputbreak = (unsigned char)c;
+			break;
+
+		case ACS_SWOOP:
+			if (len < 3)
+				break;
+			/* not yet implemented */
+			len -= 3;
+			break;
+
+		case ACS_STEPS:
+			if (len < 7)
+				break;
+			get_user(step, p++);
+			len--;
+			get_user(c, p++);
+			f1 = (unsigned char)c;
+			get_user(c, p++);
+			f1 |= ((int)(unsigned char)c << 8);
+			len -= 2;
+			get_user(c, p++);
+			f2 = (unsigned char)c;
+			get_user(c, p++);
+			f2 |= ((int)(unsigned char)c << 8);
+			len -= 2;
+			get_user(c, p++);
+			duration = (unsigned char)c;
+			get_user(c, p++);
+			duration |= ((int)(unsigned char)c << 8);
+			len -= 2;
+			ttyclicks_steps(f1, f2, step, duration);
+			break;
+
+		case ACS_REFRESH:
+			raw_spin_lock_irqsave(&acslock, irqflags);
+			if (rbuf_head <= rbuf_end - 4) {
+				*rbuf_head = ACS_REFRESH;
+				if (rbuf_head == rbuf_tail)
+					wake_up_interruptible(&wq);
+				rbuf_head += 4;
+			}
+			raw_spin_unlock_irqrestore(&acslock, irqflags);
+			break;
+
+		case ACS_PUSH_TTY:
+			if (len < 2)
+				break;
+			get_user(c, p++);
+			isize = (unsigned char)c;
+			get_user(c, p++);
+			isize |= ((int)(unsigned char)c << 8);
+			len -= 2;
+			if (len < isize)
+				break;
+			tty_pushstring(p, isize);
+			p += isize, len -= isize;
+			break;
+
+		case ACS_BUFSIZE:
+			if (len < 2)
+				break;
+			get_user(c, p++);
+			isize = (unsigned char)c;
+			get_user(c, p++);
+			isize |= ((int)(unsigned char)c << 8);
+			len -= 2;
+			if (isize < 256)
+				isize = 256;
+			if (isize >= 65536)
+				isize = 65535;
+			user_bufsize = isize;
+			break;
+
+		}		/* switch */
+	}			/* loop processing config instructions */
+
+	bytes_write = p - buf;
+	*offset += bytes_write;
+	return bytes_write;
+}				/* device_write */
+
+static unsigned int device_poll(struct file *fp, poll_table * pt)
+{
+	unsigned int mask = 0;
+	if (!in_use)
+		return 0;	/* should never happen */
+/* we don't support poll writing. How to figure if the buffer is not full? */
+	if (rbuf_head > rbuf_tail)
+		mask = POLLIN | POLLRDNORM;
+	poll_wait(fp, &wq, pt);
+	return mask;
+}
+
+static const struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.open = device_open,
+	.release = device_close,
+	.read = device_read,
+	.write = device_write,
+	.poll = device_poll,
+};
+
+static struct miscdevice acsint_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "acsint",
+	.fops = &fops,
+};
+
+/* Variables to remember the entered keystrokes, to watch for echo.
+ * If these keys reappear on screen in a timely fashion, without other output,
+ * they are considered echo chars. */
+
+#define MAXKEYPENDING 8
+struct keyhold {
+	unsigned int unicode;
+	unsigned long when;	/* in jiffies */
+	int keytype;		/* code or sym or unicode */
+};
+static struct keyhold keystack[MAXKEYPENDING];
+static short nkeypending;	/* number of keys pending */
+
+/* Key echo states:
+ * 0 nothing special
+ * 1 tab or ^i match space, more spaces coming
+* 2 return matches cr, lf coming back
+ * 3 escape matches ^[
+ * 4 delete or ^h matches ^h, space is next
+ * 5 ^h expected, move back to 0
+*/
+static short keyechostate;
+#define flushInKeyBuffer() (nkeypending = keyechostate = 0)
+#define ECHOEXPIRE 3		/* in seconds */
+
+static void dropKeysPending(int mark)
+{
+	int i, j;
+	for (i = 0, j = mark; j < nkeypending; ++i, ++j)
+		keystack[i] = keystack[j];
+	nkeypending -= mark;
+	if (!nkeypending)
+		flushInKeyBuffer();
+}				/* dropKeysPending */
+
+/* char is displayed on screen; is it echo? */
+/* This is run from within a spinlock */
+static int isEcho(unsigned int c)
+{
+	unsigned int d;
+	int j;
+
+/* when echo is based only on states */
+	if (keyechostate == 1 && c == ' ')
+		return 2;
+	if (keyechostate == 2 && c == '\n') {
+		keyechostate = 0;
+		return 2;
+	}
+	if (keyechostate == 3 && c == '[') {
+		keyechostate = 0;
+		return 2;
+	}
+	if (keyechostate == 4 && c == ' ') {
+		keyechostate = 5;
+		return 2;
+	}
+	if (keyechostate == 5 && c == '\b') {
+		keyechostate = 0;
+		return 2;
+	}
+
+	keyechostate = 0;
+	if (!nkeypending)
+		return 0;
+
+/* drop old keys */
+	for (j = 0; j < nkeypending; ++j)
+		if ((long)jiffies - (long)keystack[j].when <= HZ * ECHOEXPIRE)
+			break;
+	if (j) {
+		dropKeysPending(j);
+		if (!nkeypending)
+			return 0;
+	}
+
+/* we need to match on the first character */
+	d = keystack[0].unicode;
+	if (d == '\t' && c == ' ') {
+		dropKeysPending(1);
+		keyechostate = 1;
+		return 2;
+	}
+	if ((d == '\r' || d == '\n') && c == '\r') {
+		dropKeysPending(1);
+		keyechostate = 2;
+		return 1;
+	}
+	if (d == '\033' && c == '^') {
+		dropKeysPending(1);
+		keyechostate = 3;
+		return 2;
+	}
+	if ((d == '\b' || d == 0x7f) && c == '\b') {
+		dropKeysPending(1);
+		keyechostate = 4;
+		return 2;
+	}
+
+	if(d == c) {
+		dropKeysPending(1);
+		return 1;
+	}
+
+	flushInKeyBuffer();
+	return 0;
+}				/* isEcho */
+
+/* Post a keystroke on to the pending log, to watch for echo.
+ * This is based on key code and shift state.
+ * I wanted to base it on KBD_UNICODE, but my system doesn't throw those events.
+ * See the sample code in keystroke().
+ * Meantime this will have to do.
+ * But it assumes ascii, and a qwerty keyboard.
+ * Let me know if there's a better way. */
+static void post4echo(int keytype, struct keyboard_notifier_param *param)
+{
+	int key = param->value;
+	int ss = param->shift & 0xf;
+	int leds = param->ledstate;
+	char keychar;
+	unsigned long irqflags;
+	struct keyhold *kp;	/* key pointer */
+
+	static const char lowercode[] =
+	    " \0331234567890-=\177\tqwertyuiop[]\r asdfghjkl;'` \\zxcvbnm,./    ";
+	static const char uppercode[] =
+	    " \033!@#$%^&*()_+\177\tQWERTYUIOP{}\r ASDFGHJKL:\"~ |ZXCVBNM<>?    ";
+
+	if (keytype == KBD_UNICODE) {
+		raw_spin_lock_irqsave(&acslock, irqflags);
+/* display key that was pushed because of KEYCODE or KEYSYM */
+		if (nkeypending
+		    && keystack[nkeypending - 1].keytype != KBD_UNICODE)
+			--nkeypending;
+		if (nkeypending == MAXKEYPENDING)
+			dropKeysPending(1);
+		kp = keystack + nkeypending;
+		kp->unicode = key;
+		kp->when = jiffies;
+		kp->keytype = keytype;
+		++nkeypending;
+		raw_spin_unlock_irqrestore(&acslock, irqflags);
+		return;
+	}
+
+/* KEYSYM not yet implemented */
+	if (keytype != KBD_KEYCODE)
+		return;
+
+	if (key == KEY_KPENTER)
+		key = KEY_ENTER;
+
+/* pull keycode down to numbers if numlock numpad keys are hit */
+	if (leds & K_NUMLOCK && (ss & ACS_SS_ALT) == 0) {
+		static const int padnumbers[] = {
+			KEY_7, KEY_8, KEY_9, 0,
+			KEY_4, KEY_5, KEY_6, 0,
+			KEY_1, KEY_2, KEY_3, KEY_0
+		};
+		if (key == KEY_KPASTERISK)
+			key = KEY_8, ss = ACS_SS_SHIFT;
+		if (key == KEY_KPSLASH)
+			key = KEY_SLASH, ss = 0;
+		if (key == KEY_KPPLUS)
+			key = KEY_EQUAL, ss = ACS_SS_SHIFT;
+		if (key == KEY_KPMINUS)
+			key = KEY_MINUS, ss = 0;
+		if (key == KEY_KPDOT)
+			key = KEY_DOT, ss = 0;
+		if (key >= KEY_KP7 && key <= KEY_KP0)
+			key = padnumbers[key - KEY_KP7], ss = 0;
+	}
+
+	if (key > KEY_SPACE)
+		return;
+
+	keychar = (ss & ACS_SS_SHIFT) ? uppercode[key] : lowercode[key];
+	if (keychar == ' ' && key != KEY_SPACE)
+		return;
+
+	if (keychar == '\r')
+		ss = 0;
+
+/* don't know how to echo alt keys */
+	if (ss & ACS_SS_ALT)
+		return;
+
+/* control letters */
+	if (ss & ACS_SS_CTRL && isalpha(keychar))
+		keychar = (keychar | 0x20) - ('a' - 1);
+
+	if (leds & K_CAPSLOCK && isalpha(keychar))
+		keychar ^= 0x20;
+
+	raw_spin_lock_irqsave(&acslock, irqflags);
+	if (nkeypending == MAXKEYPENDING)
+		dropKeysPending(1);
+	kp = keystack + nkeypending;
+	kp->unicode = keychar;
+	kp->when = jiffies;
+	kp->keytype = keytype;
+	++nkeypending;
+	raw_spin_unlock_irqrestore(&acslock, irqflags);
+}				/* post4echo */
+
+/* Push a character onto the tty log.
+ * Called from the vt notifyer and from my printk console. */
+static void pushlog(unsigned int c, int mino, bool from_vt)
+{
+	unsigned long irqflags;
+	bool wake = false;
+	bool at_head = false;	/* output is at the head */
+	bool throw = false;	/* throw the MORECHARS event */
+	int echo = 0;
+	struct cbuf *cb = cbuf_tty[mino];
+
+	if (!cb)
+		return;
+
+	raw_spin_lock_irqsave(&acslock, irqflags);
+
+	if (mino == fg_console) {
+		if (from_vt)
+			echo = isEcho(c);
+		if (cb->mark == cb->head || cb->echopoint == cb->head)
+			at_head = true;
+		if (at_head || echo)
+			throw = true;
+		if (!echo) {
+			if (last_oj && outputbreak &&
+			    (long)jiffies - (long)last_oj <
+			    HZ * outputbreak / 10)
+				throw = false;
+			last_oj = jiffies;
+			if (last_oj == 0)
+				last_oj = 1;
+		}
+	}
+
+	cb_append(cb, c);
+
+	if (throw && rbuf_head <= rbuf_end - 8) {
+		/* throw the MORECHARS event */
+		if (rbuf_head == rbuf_tail)
+			wake = true;
+		rbuf_head[0] = ACS_TTY_MORECHARS;
+		rbuf_head[1] = echo;
+			*(unsigned int *)(rbuf_head + 4) = c;
+		rbuf_head += 8;
+		if (echo)
+			cb->echopoint = cb->head;
+	}
+
+	if (wake)
+		wake_up_interruptible(&wq);
+	raw_spin_unlock_irqrestore(&acslock, irqflags);
+}				/* pushlog */
+
+/*
+ * We need a console to capture printk() text
+ * and push it onto the buffer.
+ * It didn't come from the tty, but we want to read it nonetheless.
+ */
+
+static void my_printk(struct console *cons, const char *msg, unsigned int len)
+{
+	char c;
+	if (!in_use)
+		return;
+	while (len--) {
+		c = *msg++;
+		pushlog((unsigned char)c, fg_console, false);
+	}
+}
+
+static struct console acsintconsole = {
+	.name = "acsint",
+	.write = my_printk,
+	.flags = CON_ENABLED,
+};
+
+/* Notifiers: keyboard events and tty events. */
+
+static int
+vt_out(struct notifier_block *this_nb, unsigned long type, void *data)
+{
+	struct vt_notifier_param *param = data;
+	struct vc_data *vc = param->vc;
+	int mino = vc->vc_num;
+	unsigned int unicode = param->c;
+	unsigned long irqflags;
+	bool wake = false;
+
+	if (!in_use)
+		return NOTIFY_DONE;
+
+	if (param->vc->vc_mode == KD_GRAPHICS && type != VT_UPDATE)
+		return NOTIFY_DONE;
+	switch (type) {
+	case VT_UPDATE:
+		if (fg_console == last_fgc)
+			break;	/* it's the same console */
+
+		last_fgc = fg_console;
+/* retry alloc on console switch */
+		cb_nomem_alloc[fg_console] = 0;
+		checkAlloc(fg_console, true);
+		last_oj = 0;
+		raw_spin_lock_irqsave(&acslock, irqflags);
+		flushInKeyBuffer();
+		if (rbuf_head <= rbuf_end - 4) {
+			if (rbuf_head == rbuf_tail)
+				wake = true;
+			rbuf_head[0] = ACS_FGC;
+			rbuf_head[1] = fg_console + 1;
+			rbuf_head += 4;
+			if (wake)
+				wake_up_interruptible(&wq);
+		}
+		raw_spin_unlock_irqrestore(&acslock, irqflags);
+		break;
+
+	case VT_PREWRITE:
+/* I don't log, or pass back, null bytes in the output stream. */
+		if (unicode == 0)
+			break;
+
+		checkAlloc(mino, true);
+		pushlog(unicode, mino, true);
+	}			/* switch */
+
+	return NOTIFY_DONE;
+}				/* vt_out */
+
+static struct notifier_block nb_vt = {
+	.notifier_call = vt_out,
+	.priority = 20
+};
+
+static int
+keystroke(struct notifier_block *this_nb, unsigned long type, void *data)
+{
+	struct keyboard_notifier_param *param = data;
+	unsigned int key = param->value;
+	int downflag = param->down;
+	int ss = param->shift;
+	int mymeta, mymask;
+	int j;
+	unsigned short action;
+	bool wake = false, keep = false, send = false;
+	bool divert, monitor, bypass;
+	unsigned long irqflags;
+
+	if (!in_use)
+		goto done;
+
+	if (param->vc->vc_mode == KD_GRAPHICS)
+		goto done;
+
+/* post any unicode events for echo */
+	if (type == KBD_UNICODE && downflag) {
+		post4echo(KBD_UNICODE, param);
+		goto done;
+	}
+
+	if (type != KBD_KEYCODE)
+		goto done;
+
+/* Capture and process keys that are meta, but not kernel meta */
+	if(key < ACS_NUM_KEYS && (mymeta = ismeta[key]) && mymeta != ACS_SS_KERNEL) {
+		mymask = 1;
+		for(j=0; j<4; ++j, mymask<<=1)
+			if(mymask & mymeta)
+				metaflag[j] = (downflag != 0);
+		return NOTIFY_STOP;
+	}
+
+/* Only the key down events */
+	if (downflag == 0)
+		goto done;
+
+	ss &= 0xf;
+/* Adjust by the user meta keys. */
+	mymask = 1;
+	for(j=0; j<4; ++j, mymask<<=1) {
+		if(metaflag[j])
+			ss |= mymask;
+	}
+
+	action = 0;
+	if (key < ACS_NUM_KEYS)
+		action = capture[key];
+
+	divert = key_divert;
+	monitor = key_monitor;
+	bypass = key_bypass;
+/* But we don't redirect the meta keys */
+	if (divert || monitor || bypass) {
+		if (key < ACS_NUM_KEYS && ismeta[key]) {
+			divert = false;
+			monitor = false;
+			bypass = false;
+		}
+	}
+
+	if (divert || monitor)
+		keep = true;
+	if (bypass) {
+		key_bypass = 0;
+		send = true;
+		goto event;
+	}
+
+/* keypad is assumed to be numbers with numlock on,
+ * and perhaps speech functions otherwise. */
+	if (param->ledstate & K_NUMLOCK &&
+	    key >= KEY_KP7 && key <= KEY_KPDOT &&
+	    key != KEY_KPMINUS && key != KEY_KPPLUS)
+		goto regular;
+
+	if (action & (1 << ss)) {
+		keep = true;
+		if(passt[key] & (1<<ss))
+			send = true;
+		goto event;
+	}
+
+regular:
+/* Just a regular key. */
+	if (!divert)
+		send = true;
+
+event:
+	if (keep) {
+		/* If this notifier is not called by an interrupt, then we need the spinlock */
+		raw_spin_lock_irqsave(&acslock, irqflags);
+		if (rbuf_head <= rbuf_end - 4) {
+			if (rbuf_head == rbuf_tail)
+				wake = true;
+			rbuf_head[0] = ACS_KEYSTROKE;
+			rbuf_head[1] = key;
+			rbuf_head[2] = ss;
+			rbuf_head[3] = param->ledstate;
+			rbuf_head += 4;
+			if (wake)
+				wake_up_interruptible(&wq);
+		}
+		raw_spin_unlock_irqrestore(&acslock, irqflags);
+	}
+
+	if (!send)
+		return NOTIFY_STOP;
+
+	post4echo(KBD_KEYCODE, param);
+	last_oj = 0;
+
+done:
+	return NOTIFY_DONE;
+}				/* keystroke */
+
+static struct notifier_block nb_key = {
+	.notifier_call = keystroke,
+	.priority = 20
+};
+
+/* load and unload the module */
+
+static int __init acsint_init(void)
+{
+	int rc;
+
+	in_use = false;
+	clear_keys();
+
+	if (major == 0)
+		rc = misc_register(&acsint_dev);
+	else
+		rc = register_chrdev(major, ACS_DEVICE, &fops);
+	if (rc)
+		return rc;
+	if (major == 0)
+		printk(KERN_NOTICE "registered acsint, major %d minor %d\n",
+		       MISC_MAJOR, acsint_dev.minor);
+
+	rc = register_vt_notifier(&nb_vt);
+	if (rc) {
+		if (major == 0)
+			misc_deregister(&acsint_dev);
+		else
+			unregister_chrdev(major, ACS_DEVICE);
+		return rc;
+	}
+
+	rc = register_keyboard_notifier(&nb_key);
+	if (rc) {
+		unregister_vt_notifier(&nb_vt);
+		if (major == 0)
+			misc_deregister(&acsint_dev);
+		else
+			unregister_chrdev(major, ACS_DEVICE);
+		return rc;
+	}
+
+	register_console(&acsintconsole);
+
+	return 0;
+}
+
+static void __exit acsint_exit(void)
+{
+	int j;
+
+	unregister_console(&acsintconsole);
+	unregister_keyboard_notifier(&nb_key);
+	unregister_vt_notifier(&nb_vt);
+	if (major == 0)
+		misc_deregister(&acsint_dev);
+	else
+		unregister_chrdev(major, ACS_DEVICE);
+
+	for (j = 0; j < MAX_NR_CONSOLES; ++j)
+		kfree(cbuf_tty[j]);
+}
+
+module_init(acsint_init);
+module_exit(acsint_exit);
--- a/include/linux/ttyclicks.h	2014-12-01 21:48:42.605022990 -0500
+++ b/include/linux/ttyclicks.h	2014-12-01 21:48:42.608023387 -0500
@@ -0,0 +1,17 @@
+#ifndef _LINUX_TTYCLICKS_H
+#define _LINUX_TTYCLICKS_H
+
+/* External prototypes for ttyclicks.c */
+/* See Documentation/accessibility/ttyclicks.txt for documentation. */
+
+extern bool ttyclicks_on;	/* speaker sounds activated */
+extern bool ttyclicks_tty;	/* speaker sounds from tty */
+extern bool ttyclicks_kmsg;	/* speaker sounds from kernel message */
+
+void ttyclicks_click(void);
+void ttyclicks_cr(void);
+void ttyclicks_bell(void);
+void ttyclicks_notes(const short *notelist);
+void ttyclicks_steps(int start, int end, int step, int duration);
+
+#endif
--- a/include/linux/acsint.h	2014-12-01 21:48:42.612023918 -0500
+++ b/include/linux/acsint.h	2014-12-01 21:48:42.615024315 -0500
@@ -0,0 +1,65 @@
+#ifndef _LINUX_ACSINT_H
+#define _LINUX_ACSINT_H
+
+/* Prototypes and definitions for the acsint device driver. */
+
+#include <linux/input.h>
+#include <linux/kd.h>
+#include <linux/keyboard.h>
+
+/* Commands that Acsint sends or receives */
+enum acs_command {
+	ACS_NULL,
+/* configuration commands */
+	ACS_BUFSIZE,		/* size of userland tty buffer */
+	ACS_CLEAR_KEYS,
+	ACS_SET_KEY,
+	ACS_UNSET_KEY,
+	ACS_ISMETA,
+	ACS_PUSH_TTY,
+/* Configure which sounds are made automatically */
+	ACS_SOUNDS,		/* on or off */
+	ACS_SOUNDS_TTY,
+	ACS_SOUNDS_KMSG,
+/* ask the driver to make specific sounds for you */
+	ACS_CLICK,
+	ACS_CR,
+	ACS_SWOOP,
+	ACS_NOTES,		/* series of notes */
+	ACS_STEPS,		/* like a scale going up or down */
+/* Request to bring the tty log up to date */
+	ACS_REFRESH,
+/* should keys go to the adapter or console or both */
+	ACS_BYPASS,		/* send next char through */
+	ACS_MONITOR,		/* to monitor keystrokes as you type */
+	ACS_DIVERT,		/* adapter grabs a string of text */
+/* Timing break between successive sections of output */
+	ACS_OBREAK,
+/* events coming back */
+	ACS_KEYSTROKE,
+	ACS_TTY_NEWCHARS,	/* the ones you haven't seen yet */
+	ACS_TTY_MORECHARS,	/* there are more chars pending */
+	ACS_FGC,		/* foreground console */
+	ACS_PRINTK,
+};
+
+/* Here is a bound; you can't capture keys at or beyond this point. */
+#define ACS_NUM_KEYS 128
+
+/* Symbolic constants for the keys are in input.h */
+
+/* Symbolic constants for the led states are in kd.h */
+
+/* Symbolic constants for the shift states are derived from keyboard.h,
+ * but I turn them into bits for you.
+ * This makes it easier to ddescribe modified key chords such as alt control X.
+ * Just or things together. */
+#define ACS_SS_SHIFT (1<<KG_SHIFT)
+#define ACS_SS_RALT (1<<KG_ALTGR)
+#define ACS_SS_CTRL (1<<KG_CTRL)
+#define ACS_SS_LALT (1<<KG_ALT)
+#define ACS_SS_ALT (ACS_SS_LALT|ACS_SS_RALT)
+
+#define ACS_KEY_T 0x20
+
+#endif
